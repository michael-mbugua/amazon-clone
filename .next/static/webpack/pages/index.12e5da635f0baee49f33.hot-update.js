/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/components/Banner.js":
/*!**********************************!*\
  !*** ./src/components/Banner.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_responsive_carousel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-responsive-carousel */ \"./node_modules/react-responsive-carousel/lib/js/index.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\nvar _jsxFileName = \"/home/moringa/Desktop/Amazon-clone/Amazon-git/amazon-clone/src/components/Banner.js\",\n    _this = undefined;\n\n\n\n\nvar Banner = function Banner() {\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 7,\n    columnNumber: 5\n  }, _this);\n};\n\n_c = Banner;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Banner);\n\nvar _c;\n\n$RefreshReg$(_c, \"Banner\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvQmFubmVyLmpzP2QxNjkiXSwibmFtZXMiOlsiQmFubmVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUdBLElBQU1BLE1BQU0sR0FBRyxTQUFUQSxNQUFTLEdBQU07QUFDakIsc0JBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQURBO0FBS0gsQ0FORDs7S0FBTUEsTTtBQVFOLCtEQUFlQSxNQUFmIiwiZmlsZSI6Ii4vc3JjL2NvbXBvbmVudHMvQmFubmVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQ2Fyb3VzZWwgfSBmcm9tICdyZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsJztcblxuXG5jb25zdCBCYW5uZXIgPSAoKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICA8ZGl2PlxuXG4gICAgPC9kaXY+XG4gICAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYW5uZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/Banner.js\n");

/***/ }),

/***/ "./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanM/NGQyNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLLEtBQTZCO0FBQ2xDO0FBQ0E7QUFDQSxFQUFFLFVBQVUsSUFBNEU7QUFDeEY7QUFDQSxFQUFFLGlDQUFxQixFQUFFLG1DQUFFO0FBQzNCO0FBQ0EsR0FBRztBQUFBLGtHQUFDO0FBQ0osRUFBRSxNQUFNLEVBRU47QUFDRixDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE3IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRpZiAoaW5uZXIpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goaW5uZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/classnames/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanM/YTE1YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsSUFBSSxJQUFxQztBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyx5RkFBNEI7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/checkPropTypes.js\n");

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\nvar has = Function.call.bind(Object.prototype.hasOwnProperty);\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanM/YjA3MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLGtEQUFVO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxnRkFBZTs7QUFFcEMsMkJBQTJCLG1CQUFPLENBQUMseUZBQTRCO0FBQy9ELHFCQUFxQixtQkFBTyxDQUFDLHFFQUFrQjs7QUFFL0M7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZCQUE2QjtBQUM3QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVSxLQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sS0FBcUMsNEZBQTRGLENBQU07QUFDN0k7QUFDQTs7QUFFQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/factoryWithTypeCheckers.js\n");

/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanM/ZDdiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxJQUFxQztBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBVTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsdUZBQTJCO0FBQ3RELENBQUMsTUFBTSxFQUlOIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ (function(module) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzPzU5YjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/ReactPropTypesSecret.js\n");

/***/ }),

/***/ "./node_modules/react-easy-swipe/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/react-easy-swipe/lib/index.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./react-swipe */ \"./node_modules/react-easy-swipe/lib/react-swipe.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (exports, _reactSwipe) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  var _reactSwipe2 = _interopRequireDefault(_reactSwipe);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  exports.default = _reactSwipe2.default;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWVhc3ktc3dpcGUvbGliL2luZGV4LmpzPzI2ZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNLElBQTBDO0FBQ2hELElBQUksaUNBQU8sQ0FBQyxPQUFTLEVBQUUsOEZBQWUsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQ2pELEdBQUcsTUFBTSxZQVFOO0FBQ0gsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LWVhc3ktc3dpcGUvbGliL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnZXhwb3J0cycsICcuL3JlYWN0LXN3aXBlJ10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCcuL3JlYWN0LXN3aXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtb2QgPSB7XG4gICAgICBleHBvcnRzOiB7fVxuICAgIH07XG4gICAgZmFjdG9yeShtb2QuZXhwb3J0cywgZ2xvYmFsLnJlYWN0U3dpcGUpO1xuICAgIGdsb2JhbC5pbmRleCA9IG1vZC5leHBvcnRzO1xuICB9XG59KSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgX3JlYWN0U3dpcGUpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfcmVhY3RTd2lwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdFN3aXBlKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gX3JlYWN0U3dpcGUyLmRlZmF1bHQ7XG59KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-easy-swipe/lib/index.js\n");

/***/ }),

/***/ "./node_modules/react-easy-swipe/lib/react-swipe.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-easy-swipe/lib/react-swipe.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! react */ \"./node_modules/react/index.js\"), __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (exports, _react, _propTypes) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.setHasSupportToCaptureOption = setHasSupportToCaptureOption;\n\n  var _react2 = _interopRequireDefault(_react);\n\n  var _propTypes2 = _interopRequireDefault(_propTypes);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  function _objectWithoutProperties(obj, keys) {\n    var target = {};\n\n    for (var i in obj) {\n      if (keys.indexOf(i) >= 0) continue;\n      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n      target[i] = obj[i];\n    }\n\n    return target;\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var supportsCaptureOption = false;\n  function setHasSupportToCaptureOption(hasSupport) {\n    supportsCaptureOption = hasSupport;\n  }\n\n  try {\n    addEventListener('test', null, Object.defineProperty({}, 'capture', { get: function get() {\n        setHasSupportToCaptureOption(true);\n      } }));\n  } catch (e) {} // eslint-disable-line no-empty\n\n  function getSafeEventHandlerOpts() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { capture: true };\n\n    return supportsCaptureOption ? options : options.capture;\n  }\n\n  /**\n   * [getPosition returns a position element that works for mouse or touch events]\n   * @param  {[Event]} event [the received event]\n   * @return {[Object]}      [x and y coords]\n   */\n  function getPosition(event) {\n    if ('touches' in event) {\n      var _event$touches$ = event.touches[0],\n          pageX = _event$touches$.pageX,\n          pageY = _event$touches$.pageY;\n\n      return { x: pageX, y: pageY };\n    }\n\n    var screenX = event.screenX,\n        screenY = event.screenY;\n\n    return { x: screenX, y: screenY };\n  }\n\n  var ReactSwipe = function (_Component) {\n    _inherits(ReactSwipe, _Component);\n\n    function ReactSwipe() {\n      var _ref;\n\n      _classCallCheck(this, ReactSwipe);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var _this = _possibleConstructorReturn(this, (_ref = ReactSwipe.__proto__ || Object.getPrototypeOf(ReactSwipe)).call.apply(_ref, [this].concat(args)));\n\n      _this._handleSwipeStart = _this._handleSwipeStart.bind(_this);\n      _this._handleSwipeMove = _this._handleSwipeMove.bind(_this);\n      _this._handleSwipeEnd = _this._handleSwipeEnd.bind(_this);\n\n      _this._onMouseDown = _this._onMouseDown.bind(_this);\n      _this._onMouseMove = _this._onMouseMove.bind(_this);\n      _this._onMouseUp = _this._onMouseUp.bind(_this);\n\n      _this._setSwiperRef = _this._setSwiperRef.bind(_this);\n      return _this;\n    }\n\n    _createClass(ReactSwipe, [{\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        if (this.swiper) {\n          this.swiper.addEventListener('touchmove', this._handleSwipeMove, getSafeEventHandlerOpts({\n            capture: true,\n            passive: false\n          }));\n        }\n      }\n    }, {\n      key: 'componentWillUnmount',\n      value: function componentWillUnmount() {\n        if (this.swiper) {\n          this.swiper.removeEventListener('touchmove', this._handleSwipeMove, getSafeEventHandlerOpts({\n            capture: true,\n            passive: false\n          }));\n        }\n      }\n    }, {\n      key: '_onMouseDown',\n      value: function _onMouseDown(event) {\n        if (!this.props.allowMouseEvents) {\n          return;\n        }\n\n        this.mouseDown = true;\n\n        document.addEventListener('mouseup', this._onMouseUp);\n        document.addEventListener('mousemove', this._onMouseMove);\n\n        this._handleSwipeStart(event);\n      }\n    }, {\n      key: '_onMouseMove',\n      value: function _onMouseMove(event) {\n        if (!this.mouseDown) {\n          return;\n        }\n\n        this._handleSwipeMove(event);\n      }\n    }, {\n      key: '_onMouseUp',\n      value: function _onMouseUp(event) {\n        this.mouseDown = false;\n\n        document.removeEventListener('mouseup', this._onMouseUp);\n        document.removeEventListener('mousemove', this._onMouseMove);\n\n        this._handleSwipeEnd(event);\n      }\n    }, {\n      key: '_handleSwipeStart',\n      value: function _handleSwipeStart(event) {\n        var _getPosition = getPosition(event),\n            x = _getPosition.x,\n            y = _getPosition.y;\n\n        this.moveStart = { x: x, y: y };\n        this.props.onSwipeStart(event);\n      }\n    }, {\n      key: '_handleSwipeMove',\n      value: function _handleSwipeMove(event) {\n        if (!this.moveStart) {\n          return;\n        }\n\n        var _getPosition2 = getPosition(event),\n            x = _getPosition2.x,\n            y = _getPosition2.y;\n\n        var deltaX = x - this.moveStart.x;\n        var deltaY = y - this.moveStart.y;\n        this.moving = true;\n\n        // handling the responsability of cancelling the scroll to\n        // the component handling the event\n        var shouldPreventDefault = this.props.onSwipeMove({\n          x: deltaX,\n          y: deltaY\n        }, event);\n\n        if (shouldPreventDefault && event.cancelable) {\n          event.preventDefault();\n        }\n\n        this.movePosition = { deltaX: deltaX, deltaY: deltaY };\n      }\n    }, {\n      key: '_handleSwipeEnd',\n      value: function _handleSwipeEnd(event) {\n        this.props.onSwipeEnd(event);\n\n        var tolerance = this.props.tolerance;\n\n\n        if (this.moving && this.movePosition) {\n          if (this.movePosition.deltaX < -tolerance) {\n            this.props.onSwipeLeft(1, event);\n          } else if (this.movePosition.deltaX > tolerance) {\n            this.props.onSwipeRight(1, event);\n          }\n          if (this.movePosition.deltaY < -tolerance) {\n            this.props.onSwipeUp(1, event);\n          } else if (this.movePosition.deltaY > tolerance) {\n            this.props.onSwipeDown(1, event);\n          }\n        }\n\n        this.moveStart = null;\n        this.moving = false;\n        this.movePosition = null;\n      }\n    }, {\n      key: '_setSwiperRef',\n      value: function _setSwiperRef(node) {\n        this.swiper = node;\n        this.props.innerRef(node);\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        var _props = this.props,\n            tagName = _props.tagName,\n            className = _props.className,\n            style = _props.style,\n            children = _props.children,\n            allowMouseEvents = _props.allowMouseEvents,\n            onSwipeUp = _props.onSwipeUp,\n            onSwipeDown = _props.onSwipeDown,\n            onSwipeLeft = _props.onSwipeLeft,\n            onSwipeRight = _props.onSwipeRight,\n            onSwipeStart = _props.onSwipeStart,\n            onSwipeMove = _props.onSwipeMove,\n            onSwipeEnd = _props.onSwipeEnd,\n            innerRef = _props.innerRef,\n            tolerance = _props.tolerance,\n            props = _objectWithoutProperties(_props, ['tagName', 'className', 'style', 'children', 'allowMouseEvents', 'onSwipeUp', 'onSwipeDown', 'onSwipeLeft', 'onSwipeRight', 'onSwipeStart', 'onSwipeMove', 'onSwipeEnd', 'innerRef', 'tolerance']);\n\n        return _react2.default.createElement(\n          this.props.tagName,\n          _extends({\n            ref: this._setSwiperRef,\n            onMouseDown: this._onMouseDown,\n            onTouchStart: this._handleSwipeStart,\n            onTouchEnd: this._handleSwipeEnd,\n            className: className,\n            style: style\n          }, props),\n          children\n        );\n      }\n    }]);\n\n    return ReactSwipe;\n  }(_react.Component);\n\n  ReactSwipe.displayName = 'ReactSwipe';\n  ReactSwipe.propTypes = {\n    tagName: _propTypes2.default.string,\n    className: _propTypes2.default.string,\n    style: _propTypes2.default.object,\n    children: _propTypes2.default.node,\n    allowMouseEvents: _propTypes2.default.bool,\n    onSwipeUp: _propTypes2.default.func,\n    onSwipeDown: _propTypes2.default.func,\n    onSwipeLeft: _propTypes2.default.func,\n    onSwipeRight: _propTypes2.default.func,\n    onSwipeStart: _propTypes2.default.func,\n    onSwipeMove: _propTypes2.default.func,\n    onSwipeEnd: _propTypes2.default.func,\n    innerRef: _propTypes2.default.func,\n    tolerance: _propTypes2.default.number.isRequired\n  };\n  ReactSwipe.defaultProps = {\n    tagName: 'div',\n    allowMouseEvents: false,\n    onSwipeUp: function onSwipeUp() {},\n    onSwipeDown: function onSwipeDown() {},\n    onSwipeLeft: function onSwipeLeft() {},\n    onSwipeRight: function onSwipeRight() {},\n    onSwipeStart: function onSwipeStart() {},\n    onSwipeMove: function onSwipeMove() {},\n    onSwipeEnd: function onSwipeEnd() {},\n    innerRef: function innerRef() {},\n\n    tolerance: 0\n  };\n  exports.default = ReactSwipe;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWVhc3ktc3dpcGUvbGliL3JlYWN0LXN3aXBlLmpzPzdlNzMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNLElBQTBDO0FBQ2hELElBQUksaUNBQU8sQ0FBQyxPQUFTLEVBQUUsaUVBQU8sRUFBRSwyRUFBWSxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDdkQsR0FBRyxNQUFNLFlBUU47QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0EsT0FBTyxFQUFFO0FBQ1QsR0FBRyxhQUFhOztBQUVoQjtBQUNBLHVGQUF1Rjs7QUFFdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxRUFBcUUsYUFBYTtBQUNsRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQyw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLDBDQUEwQztBQUMxQyx3Q0FBd0M7QUFDeEMsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LWVhc3ktc3dpcGUvbGliL3JlYWN0LXN3aXBlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnZXhwb3J0cycsICdyZWFjdCcsICdwcm9wLXR5cGVzJ10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyZWFjdCcpLCByZXF1aXJlKCdwcm9wLXR5cGVzJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtb2QgPSB7XG4gICAgICBleHBvcnRzOiB7fVxuICAgIH07XG4gICAgZmFjdG9yeShtb2QuZXhwb3J0cywgZ2xvYmFsLnJlYWN0LCBnbG9iYWwucHJvcFR5cGVzKTtcbiAgICBnbG9iYWwucmVhY3RTd2lwZSA9IG1vZC5leHBvcnRzO1xuICB9XG59KSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgX3JlYWN0LCBfcHJvcFR5cGVzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5zZXRIYXNTdXBwb3J0VG9DYXB0dXJlT3B0aW9uID0gc2V0SGFzU3VwcG9ydFRvQ2FwdHVyZU9wdGlvbjtcblxuICB2YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuICB2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG4gIH1cblxuICB2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgIH07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKCFzZWxmKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgICB9XG5cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG4gIH1cblxuICB2YXIgc3VwcG9ydHNDYXB0dXJlT3B0aW9uID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHNldEhhc1N1cHBvcnRUb0NhcHR1cmVPcHRpb24oaGFzU3VwcG9ydCkge1xuICAgIHN1cHBvcnRzQ2FwdHVyZU9wdGlvbiA9IGhhc1N1cHBvcnQ7XG4gIH1cblxuICB0cnkge1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdjYXB0dXJlJywgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgc2V0SGFzU3VwcG9ydFRvQ2FwdHVyZU9wdGlvbih0cnVlKTtcbiAgICAgIH0gfSkpO1xuICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG5cbiAgZnVuY3Rpb24gZ2V0U2FmZUV2ZW50SGFuZGxlck9wdHMoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHsgY2FwdHVyZTogdHJ1ZSB9O1xuXG4gICAgcmV0dXJuIHN1cHBvcnRzQ2FwdHVyZU9wdGlvbiA/IG9wdGlvbnMgOiBvcHRpb25zLmNhcHR1cmU7XG4gIH1cblxuICAvKipcbiAgICogW2dldFBvc2l0aW9uIHJldHVybnMgYSBwb3NpdGlvbiBlbGVtZW50IHRoYXQgd29ya3MgZm9yIG1vdXNlIG9yIHRvdWNoIGV2ZW50c11cbiAgICogQHBhcmFtICB7W0V2ZW50XX0gZXZlbnQgW3RoZSByZWNlaXZlZCBldmVudF1cbiAgICogQHJldHVybiB7W09iamVjdF19ICAgICAgW3ggYW5kIHkgY29vcmRzXVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UG9zaXRpb24oZXZlbnQpIHtcbiAgICBpZiAoJ3RvdWNoZXMnIGluIGV2ZW50KSB7XG4gICAgICB2YXIgX2V2ZW50JHRvdWNoZXMkID0gZXZlbnQudG91Y2hlc1swXSxcbiAgICAgICAgICBwYWdlWCA9IF9ldmVudCR0b3VjaGVzJC5wYWdlWCxcbiAgICAgICAgICBwYWdlWSA9IF9ldmVudCR0b3VjaGVzJC5wYWdlWTtcblxuICAgICAgcmV0dXJuIHsgeDogcGFnZVgsIHk6IHBhZ2VZIH07XG4gICAgfVxuXG4gICAgdmFyIHNjcmVlblggPSBldmVudC5zY3JlZW5YLFxuICAgICAgICBzY3JlZW5ZID0gZXZlbnQuc2NyZWVuWTtcblxuICAgIHJldHVybiB7IHg6IHNjcmVlblgsIHk6IHNjcmVlblkgfTtcbiAgfVxuXG4gIHZhciBSZWFjdFN3aXBlID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoUmVhY3RTd2lwZSwgX0NvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBSZWFjdFN3aXBlKCkge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWFjdFN3aXBlKTtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBSZWFjdFN3aXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUmVhY3RTd2lwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpO1xuXG4gICAgICBfdGhpcy5faGFuZGxlU3dpcGVTdGFydCA9IF90aGlzLl9oYW5kbGVTd2lwZVN0YXJ0LmJpbmQoX3RoaXMpO1xuICAgICAgX3RoaXMuX2hhbmRsZVN3aXBlTW92ZSA9IF90aGlzLl9oYW5kbGVTd2lwZU1vdmUuYmluZChfdGhpcyk7XG4gICAgICBfdGhpcy5faGFuZGxlU3dpcGVFbmQgPSBfdGhpcy5faGFuZGxlU3dpcGVFbmQuYmluZChfdGhpcyk7XG5cbiAgICAgIF90aGlzLl9vbk1vdXNlRG93biA9IF90aGlzLl9vbk1vdXNlRG93bi5iaW5kKF90aGlzKTtcbiAgICAgIF90aGlzLl9vbk1vdXNlTW92ZSA9IF90aGlzLl9vbk1vdXNlTW92ZS5iaW5kKF90aGlzKTtcbiAgICAgIF90aGlzLl9vbk1vdXNlVXAgPSBfdGhpcy5fb25Nb3VzZVVwLmJpbmQoX3RoaXMpO1xuXG4gICAgICBfdGhpcy5fc2V0U3dpcGVyUmVmID0gX3RoaXMuX3NldFN3aXBlclJlZi5iaW5kKF90aGlzKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUmVhY3RTd2lwZSwgW3tcbiAgICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3dpcGVyKSB7XG4gICAgICAgICAgdGhpcy5zd2lwZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlU3dpcGVNb3ZlLCBnZXRTYWZlRXZlbnRIYW5kbGVyT3B0cyh7XG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN3aXBlcikge1xuICAgICAgICAgIHRoaXMuc3dpcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZVN3aXBlTW92ZSwgZ2V0U2FmZUV2ZW50SGFuZGxlck9wdHMoe1xuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX29uTW91c2VEb3duJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLmFsbG93TW91c2VFdmVudHMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vdXNlRG93biA9IHRydWU7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVTd2lwZVN0YXJ0KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfb25Nb3VzZU1vdmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMubW91c2VEb3duKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGFuZGxlU3dpcGVNb3ZlKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfb25Nb3VzZVVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gZmFsc2U7XG5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVTd2lwZUVuZChldmVudCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2hhbmRsZVN3aXBlU3RhcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVTd2lwZVN0YXJ0KGV2ZW50KSB7XG4gICAgICAgIHZhciBfZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbihldmVudCksXG4gICAgICAgICAgICB4ID0gX2dldFBvc2l0aW9uLngsXG4gICAgICAgICAgICB5ID0gX2dldFBvc2l0aW9uLnk7XG5cbiAgICAgICAgdGhpcy5tb3ZlU3RhcnQgPSB7IHg6IHgsIHk6IHkgfTtcbiAgICAgICAgdGhpcy5wcm9wcy5vblN3aXBlU3RhcnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19oYW5kbGVTd2lwZU1vdmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVTd2lwZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vdmVTdGFydCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfZ2V0UG9zaXRpb24yID0gZ2V0UG9zaXRpb24oZXZlbnQpLFxuICAgICAgICAgICAgeCA9IF9nZXRQb3NpdGlvbjIueCxcbiAgICAgICAgICAgIHkgPSBfZ2V0UG9zaXRpb24yLnk7XG5cbiAgICAgICAgdmFyIGRlbHRhWCA9IHggLSB0aGlzLm1vdmVTdGFydC54O1xuICAgICAgICB2YXIgZGVsdGFZID0geSAtIHRoaXMubW92ZVN0YXJ0Lnk7XG4gICAgICAgIHRoaXMubW92aW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyBoYW5kbGluZyB0aGUgcmVzcG9uc2FiaWxpdHkgb2YgY2FuY2VsbGluZyB0aGUgc2Nyb2xsIHRvXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgaGFuZGxpbmcgdGhlIGV2ZW50XG4gICAgICAgIHZhciBzaG91bGRQcmV2ZW50RGVmYXVsdCA9IHRoaXMucHJvcHMub25Td2lwZU1vdmUoe1xuICAgICAgICAgIHg6IGRlbHRhWCxcbiAgICAgICAgICB5OiBkZWx0YVlcbiAgICAgICAgfSwgZXZlbnQpO1xuXG4gICAgICAgIGlmIChzaG91bGRQcmV2ZW50RGVmYXVsdCAmJiBldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW92ZVBvc2l0aW9uID0geyBkZWx0YVg6IGRlbHRhWCwgZGVsdGFZOiBkZWx0YVkgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaGFuZGxlU3dpcGVFbmQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVTd2lwZUVuZChldmVudCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uU3dpcGVFbmQoZXZlbnQpO1xuXG4gICAgICAgIHZhciB0b2xlcmFuY2UgPSB0aGlzLnByb3BzLnRvbGVyYW5jZTtcblxuXG4gICAgICAgIGlmICh0aGlzLm1vdmluZyAmJiB0aGlzLm1vdmVQb3NpdGlvbikge1xuICAgICAgICAgIGlmICh0aGlzLm1vdmVQb3NpdGlvbi5kZWx0YVggPCAtdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uU3dpcGVMZWZ0KDEsIGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubW92ZVBvc2l0aW9uLmRlbHRhWCA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblN3aXBlUmlnaHQoMSwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5tb3ZlUG9zaXRpb24uZGVsdGFZIDwgLXRvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblN3aXBlVXAoMSwgZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tb3ZlUG9zaXRpb24uZGVsdGFZID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uU3dpcGVEb3duKDEsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vdmVTdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMubW92aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW92ZVBvc2l0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0U3dpcGVyUmVmJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U3dpcGVyUmVmKG5vZGUpIHtcbiAgICAgICAgdGhpcy5zd2lwZXIgPSBub2RlO1xuICAgICAgICB0aGlzLnByb3BzLmlubmVyUmVmKG5vZGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlbmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHRhZ05hbWUgPSBfcHJvcHMudGFnTmFtZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IF9wcm9wcy5jbGFzc05hbWUsXG4gICAgICAgICAgICBzdHlsZSA9IF9wcm9wcy5zdHlsZSxcbiAgICAgICAgICAgIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgYWxsb3dNb3VzZUV2ZW50cyA9IF9wcm9wcy5hbGxvd01vdXNlRXZlbnRzLFxuICAgICAgICAgICAgb25Td2lwZVVwID0gX3Byb3BzLm9uU3dpcGVVcCxcbiAgICAgICAgICAgIG9uU3dpcGVEb3duID0gX3Byb3BzLm9uU3dpcGVEb3duLFxuICAgICAgICAgICAgb25Td2lwZUxlZnQgPSBfcHJvcHMub25Td2lwZUxlZnQsXG4gICAgICAgICAgICBvblN3aXBlUmlnaHQgPSBfcHJvcHMub25Td2lwZVJpZ2h0LFxuICAgICAgICAgICAgb25Td2lwZVN0YXJ0ID0gX3Byb3BzLm9uU3dpcGVTdGFydCxcbiAgICAgICAgICAgIG9uU3dpcGVNb3ZlID0gX3Byb3BzLm9uU3dpcGVNb3ZlLFxuICAgICAgICAgICAgb25Td2lwZUVuZCA9IF9wcm9wcy5vblN3aXBlRW5kLFxuICAgICAgICAgICAgaW5uZXJSZWYgPSBfcHJvcHMuaW5uZXJSZWYsXG4gICAgICAgICAgICB0b2xlcmFuY2UgPSBfcHJvcHMudG9sZXJhbmNlLFxuICAgICAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ3RhZ05hbWUnLCAnY2xhc3NOYW1lJywgJ3N0eWxlJywgJ2NoaWxkcmVuJywgJ2FsbG93TW91c2VFdmVudHMnLCAnb25Td2lwZVVwJywgJ29uU3dpcGVEb3duJywgJ29uU3dpcGVMZWZ0JywgJ29uU3dpcGVSaWdodCcsICdvblN3aXBlU3RhcnQnLCAnb25Td2lwZU1vdmUnLCAnb25Td2lwZUVuZCcsICdpbm5lclJlZicsICd0b2xlcmFuY2UnXSk7XG5cbiAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIHRoaXMucHJvcHMudGFnTmFtZSxcbiAgICAgICAgICBfZXh0ZW5kcyh7XG4gICAgICAgICAgICByZWY6IHRoaXMuX3NldFN3aXBlclJlZixcbiAgICAgICAgICAgIG9uTW91c2VEb3duOiB0aGlzLl9vbk1vdXNlRG93bixcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5faGFuZGxlU3dpcGVTdGFydCxcbiAgICAgICAgICAgIG9uVG91Y2hFbmQ6IHRoaXMuX2hhbmRsZVN3aXBlRW5kLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgICAgICBzdHlsZTogc3R5bGVcbiAgICAgICAgICB9LCBwcm9wcyksXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUmVhY3RTd2lwZTtcbiAgfShfcmVhY3QuQ29tcG9uZW50KTtcblxuICBSZWFjdFN3aXBlLmRpc3BsYXlOYW1lID0gJ1JlYWN0U3dpcGUnO1xuICBSZWFjdFN3aXBlLnByb3BUeXBlcyA9IHtcbiAgICB0YWdOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgICBjbGFzc05hbWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuICAgIHN0eWxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcbiAgICBjaGlsZHJlbjogX3Byb3BUeXBlczIuZGVmYXVsdC5ub2RlLFxuICAgIGFsbG93TW91c2VFdmVudHM6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgICBvblN3aXBlVXA6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgICBvblN3aXBlRG93bjogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuICAgIG9uU3dpcGVMZWZ0OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gICAgb25Td2lwZVJpZ2h0OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gICAgb25Td2lwZVN0YXJ0OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gICAgb25Td2lwZU1vdmU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgICBvblN3aXBlRW5kOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gICAgaW5uZXJSZWY6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgICB0b2xlcmFuY2U6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWRcbiAgfTtcbiAgUmVhY3RTd2lwZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgdGFnTmFtZTogJ2RpdicsXG4gICAgYWxsb3dNb3VzZUV2ZW50czogZmFsc2UsXG4gICAgb25Td2lwZVVwOiBmdW5jdGlvbiBvblN3aXBlVXAoKSB7fSxcbiAgICBvblN3aXBlRG93bjogZnVuY3Rpb24gb25Td2lwZURvd24oKSB7fSxcbiAgICBvblN3aXBlTGVmdDogZnVuY3Rpb24gb25Td2lwZUxlZnQoKSB7fSxcbiAgICBvblN3aXBlUmlnaHQ6IGZ1bmN0aW9uIG9uU3dpcGVSaWdodCgpIHt9LFxuICAgIG9uU3dpcGVTdGFydDogZnVuY3Rpb24gb25Td2lwZVN0YXJ0KCkge30sXG4gICAgb25Td2lwZU1vdmU6IGZ1bmN0aW9uIG9uU3dpcGVNb3ZlKCkge30sXG4gICAgb25Td2lwZUVuZDogZnVuY3Rpb24gb25Td2lwZUVuZCgpIHt9LFxuICAgIGlubmVyUmVmOiBmdW5jdGlvbiBpbm5lclJlZigpIHt9LFxuXG4gICAgdG9sZXJhbmNlOiAwXG4gIH07XG4gIGV4cG9ydHMuZGVmYXVsdCA9IFJlYWN0U3dpcGU7XG59KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-easy-swipe/lib/react-swipe.js\n");

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcz9hOGY1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7Ozs7QUFJYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLFlBQVk7QUFDWixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLDBCQUEwQjtBQUMxQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-is/cjs/react-is.development.js\n");

/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzPzRjZWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsRUFBRSxnSUFBeUQ7QUFDM0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-is/index.js\n");

/***/ }),

/***/ "./node_modules/react-responsive-carousel/lib/js/CSSTranslate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-responsive-carousel/lib/js/CSSTranslate.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _default = function _default(position, metric, axis) {\n  var positionPercent = position === 0 ? position : position + metric;\n  var positionCss = axis === 'horizontal' ? [positionPercent, 0, 0] : [0, positionPercent, 0];\n  var transitionProp = 'translate3d';\n  var translatedPosition = '(' + positionCss.join(',') + ')';\n  return transitionProp + translatedPosition;\n};\n\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2pzL0NTU1RyYW5zbGF0ZS5qcz9lYTY3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsL2xpYi9qcy9DU1NUcmFuc2xhdGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQocG9zaXRpb24sIG1ldHJpYywgYXhpcykge1xuICB2YXIgcG9zaXRpb25QZXJjZW50ID0gcG9zaXRpb24gPT09IDAgPyBwb3NpdGlvbiA6IHBvc2l0aW9uICsgbWV0cmljO1xuICB2YXIgcG9zaXRpb25Dc3MgPSBheGlzID09PSAnaG9yaXpvbnRhbCcgPyBbcG9zaXRpb25QZXJjZW50LCAwLCAwXSA6IFswLCBwb3NpdGlvblBlcmNlbnQsIDBdO1xuICB2YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNsYXRlM2QnO1xuICB2YXIgdHJhbnNsYXRlZFBvc2l0aW9uID0gJygnICsgcG9zaXRpb25Dc3Muam9pbignLCcpICsgJyknO1xuICByZXR1cm4gdHJhbnNpdGlvblByb3AgKyB0cmFuc2xhdGVkUG9zaXRpb247XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-responsive-carousel/lib/js/CSSTranslate.js\n");

/***/ }),

/***/ "./node_modules/react-responsive-carousel/lib/js/components/Carousel/animations.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/react-responsive-carousel/lib/js/components/Carousel/animations.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.fadeAnimationHandler = exports.slideStopSwipingHandler = exports.slideSwipeAnimationHandler = exports.slideAnimationHandler = void 0;\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _CSSTranslate = _interopRequireDefault(__webpack_require__(/*! ../../CSSTranslate */ \"./node_modules/react-responsive-carousel/lib/js/CSSTranslate.js\"));\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./node_modules/react-responsive-carousel/lib/js/components/Carousel/utils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Main animation handler for the default 'sliding' style animation\n * @param props\n * @param state\n */\nvar slideAnimationHandler = function slideAnimationHandler(props, state) {\n  var returnStyles = {};\n  var selectedItem = state.selectedItem;\n  var previousItem = selectedItem;\n  var lastPosition = _react.Children.count(props.children) - 1;\n  var needClonedSlide = props.infiniteLoop && (selectedItem < 0 || selectedItem > lastPosition); // Handle list position if it needs a clone\n\n  if (needClonedSlide) {\n    if (previousItem < 0) {\n      if (props.centerMode && props.centerSlidePercentage && props.axis === 'horizontal') {\n        returnStyles.itemListStyle = (0, _utils.setPosition)(-(lastPosition + 2) * props.centerSlidePercentage - (100 - props.centerSlidePercentage) / 2, props.axis);\n      } else {\n        returnStyles.itemListStyle = (0, _utils.setPosition)(-(lastPosition + 2) * 100, props.axis);\n      }\n    } else if (previousItem > lastPosition) {\n      returnStyles.itemListStyle = (0, _utils.setPosition)(0, props.axis);\n    }\n\n    return returnStyles;\n  }\n\n  var currentPosition = (0, _utils.getPosition)(selectedItem, props); // if 3d is available, let's take advantage of the performance of transform\n\n  var transformProp = (0, _CSSTranslate.default)(currentPosition, '%', props.axis);\n  var transitionTime = props.transitionTime + 'ms';\n  returnStyles.itemListStyle = {\n    WebkitTransform: transformProp,\n    msTransform: transformProp,\n    OTransform: transformProp,\n    transform: transformProp\n  };\n\n  if (!state.swiping) {\n    returnStyles.itemListStyle = _objectSpread(_objectSpread({}, returnStyles.itemListStyle), {}, {\n      WebkitTransitionDuration: transitionTime,\n      MozTransitionDuration: transitionTime,\n      OTransitionDuration: transitionTime,\n      transitionDuration: transitionTime,\n      msTransitionDuration: transitionTime\n    });\n  }\n\n  return returnStyles;\n};\n/**\n * Swiping animation handler for the default 'sliding' style animation\n * @param delta\n * @param props\n * @param state\n * @param setState\n */\n\n\nexports.slideAnimationHandler = slideAnimationHandler;\n\nvar slideSwipeAnimationHandler = function slideSwipeAnimationHandler(delta, props, state, setState) {\n  var returnStyles = {};\n  var isHorizontal = props.axis === 'horizontal';\n\n  var childrenLength = _react.Children.count(props.children);\n\n  var initialBoundry = 0;\n  var currentPosition = (0, _utils.getPosition)(state.selectedItem, props);\n  var finalBoundry = props.infiniteLoop ? (0, _utils.getPosition)(childrenLength - 1, props) - 100 : (0, _utils.getPosition)(childrenLength - 1, props);\n  var axisDelta = isHorizontal ? delta.x : delta.y;\n  var handledDelta = axisDelta; // prevent user from swiping left out of boundaries\n\n  if (currentPosition === initialBoundry && axisDelta > 0) {\n    handledDelta = 0;\n  } // prevent user from swiping right out of boundaries\n\n\n  if (currentPosition === finalBoundry && axisDelta < 0) {\n    handledDelta = 0;\n  }\n\n  var position = currentPosition + 100 / (state.itemSize / handledDelta);\n  var hasMoved = Math.abs(axisDelta) > props.swipeScrollTolerance;\n\n  if (props.infiniteLoop && hasMoved) {\n    // When allowing infinite loop, if we slide left from position 0 we reveal the cloned last slide that appears before it\n    // if we slide even further we need to jump to other side so it can continue - and vice versa for the last slide\n    if (state.selectedItem === 0 && position > -100) {\n      position -= childrenLength * 100;\n    } else if (state.selectedItem === childrenLength - 1 && position < -childrenLength * 100) {\n      position += childrenLength * 100;\n    }\n  }\n\n  if (!props.preventMovementUntilSwipeScrollTolerance || hasMoved || state.swipeMovementStarted) {\n    if (!state.swipeMovementStarted) {\n      setState({\n        swipeMovementStarted: true\n      });\n    }\n\n    returnStyles.itemListStyle = (0, _utils.setPosition)(position, props.axis);\n  } //allows scroll if the swipe was within the tolerance\n\n\n  if (hasMoved && !state.cancelClick) {\n    setState({\n      cancelClick: true\n    });\n  }\n\n  return returnStyles;\n};\n/**\n * Default 'sliding' style animination handler for when a swipe action stops.\n * @param props\n * @param state\n */\n\n\nexports.slideSwipeAnimationHandler = slideSwipeAnimationHandler;\n\nvar slideStopSwipingHandler = function slideStopSwipingHandler(props, state) {\n  var currentPosition = (0, _utils.getPosition)(state.selectedItem, props);\n  var itemListStyle = (0, _utils.setPosition)(currentPosition, props.axis);\n  return {\n    itemListStyle: itemListStyle\n  };\n};\n/**\n * Main animation handler for the default 'fade' style animation\n * @param props\n * @param state\n */\n\n\nexports.slideStopSwipingHandler = slideStopSwipingHandler;\n\nvar fadeAnimationHandler = function fadeAnimationHandler(props, state) {\n  var transitionTime = props.transitionTime + 'ms';\n  var transitionTimingFunction = 'ease-in-out';\n  var slideStyle = {\n    position: 'absolute',\n    display: 'block',\n    zIndex: -2,\n    minHeight: '100%',\n    opacity: 0,\n    top: 0,\n    right: 0,\n    left: 0,\n    bottom: 0,\n    transitionTimingFunction: transitionTimingFunction,\n    msTransitionTimingFunction: transitionTimingFunction,\n    MozTransitionTimingFunction: transitionTimingFunction,\n    WebkitTransitionTimingFunction: transitionTimingFunction,\n    OTransitionTimingFunction: transitionTimingFunction\n  };\n\n  if (!state.swiping) {\n    slideStyle = _objectSpread(_objectSpread({}, slideStyle), {}, {\n      WebkitTransitionDuration: transitionTime,\n      MozTransitionDuration: transitionTime,\n      OTransitionDuration: transitionTime,\n      transitionDuration: transitionTime,\n      msTransitionDuration: transitionTime\n    });\n  }\n\n  return {\n    slideStyle: slideStyle,\n    selectedStyle: _objectSpread(_objectSpread({}, slideStyle), {}, {\n      opacity: 1,\n      position: 'relative'\n    }),\n    prevStyle: _objectSpread({}, slideStyle)\n  };\n};\n\nexports.fadeAnimationHandler = fadeAnimationHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2pzL2NvbXBvbmVudHMvQ2Fyb3VzZWwvYW5pbWF0aW9ucy5qcz9hYjQ5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLDRCQUE0QixHQUFHLCtCQUErQixHQUFHLGtDQUFrQyxHQUFHLDZCQUE2Qjs7QUFFbkksYUFBYSxtQkFBTyxDQUFDLDRDQUFPOztBQUU1QiwyQ0FBMkMsbUJBQU8sQ0FBQywyRkFBb0I7O0FBRXZFLGFBQWEsbUJBQU8sQ0FBQyw2RkFBUzs7QUFFOUIsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLDBDQUEwQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw4REFBOEQsZ0VBQWdFLEVBQUUsRUFBRSxnQ0FBZ0MsRUFBRSxhQUFhOztBQUVuVixnQ0FBZ0MsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHVEQUF1RCwyQ0FBMkMsRUFBRSxFQUFFLEVBQUUsNkNBQTZDLDJFQUEyRSxFQUFFLE9BQU8saURBQWlELGtGQUFrRixFQUFFLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRXBoQiwyQ0FBMkMsa0JBQWtCLGtDQUFrQyxxRUFBcUUsRUFBRSxFQUFFLE9BQU8sa0JBQWtCLEVBQUUsWUFBWTs7QUFFL007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7O0FBRWhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtEQUErRCxpQ0FBaUM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUEsNEJBQTRCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2pzL2NvbXBvbmVudHMvQ2Fyb3VzZWwvYW5pbWF0aW9ucy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mYWRlQW5pbWF0aW9uSGFuZGxlciA9IGV4cG9ydHMuc2xpZGVTdG9wU3dpcGluZ0hhbmRsZXIgPSBleHBvcnRzLnNsaWRlU3dpcGVBbmltYXRpb25IYW5kbGVyID0gZXhwb3J0cy5zbGlkZUFuaW1hdGlvbkhhbmRsZXIgPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbnZhciBfQ1NTVHJhbnNsYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vQ1NTVHJhbnNsYXRlXCIpKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBNYWluIGFuaW1hdGlvbiBoYW5kbGVyIGZvciB0aGUgZGVmYXVsdCAnc2xpZGluZycgc3R5bGUgYW5pbWF0aW9uXG4gKiBAcGFyYW0gcHJvcHNcbiAqIEBwYXJhbSBzdGF0ZVxuICovXG52YXIgc2xpZGVBbmltYXRpb25IYW5kbGVyID0gZnVuY3Rpb24gc2xpZGVBbmltYXRpb25IYW5kbGVyKHByb3BzLCBzdGF0ZSkge1xuICB2YXIgcmV0dXJuU3R5bGVzID0ge307XG4gIHZhciBzZWxlY3RlZEl0ZW0gPSBzdGF0ZS5zZWxlY3RlZEl0ZW07XG4gIHZhciBwcmV2aW91c0l0ZW0gPSBzZWxlY3RlZEl0ZW07XG4gIHZhciBsYXN0UG9zaXRpb24gPSBfcmVhY3QuQ2hpbGRyZW4uY291bnQocHJvcHMuY2hpbGRyZW4pIC0gMTtcbiAgdmFyIG5lZWRDbG9uZWRTbGlkZSA9IHByb3BzLmluZmluaXRlTG9vcCAmJiAoc2VsZWN0ZWRJdGVtIDwgMCB8fCBzZWxlY3RlZEl0ZW0gPiBsYXN0UG9zaXRpb24pOyAvLyBIYW5kbGUgbGlzdCBwb3NpdGlvbiBpZiBpdCBuZWVkcyBhIGNsb25lXG5cbiAgaWYgKG5lZWRDbG9uZWRTbGlkZSkge1xuICAgIGlmIChwcmV2aW91c0l0ZW0gPCAwKSB7XG4gICAgICBpZiAocHJvcHMuY2VudGVyTW9kZSAmJiBwcm9wcy5jZW50ZXJTbGlkZVBlcmNlbnRhZ2UgJiYgcHJvcHMuYXhpcyA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgIHJldHVyblN0eWxlcy5pdGVtTGlzdFN0eWxlID0gKDAsIF91dGlscy5zZXRQb3NpdGlvbikoLShsYXN0UG9zaXRpb24gKyAyKSAqIHByb3BzLmNlbnRlclNsaWRlUGVyY2VudGFnZSAtICgxMDAgLSBwcm9wcy5jZW50ZXJTbGlkZVBlcmNlbnRhZ2UpIC8gMiwgcHJvcHMuYXhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm5TdHlsZXMuaXRlbUxpc3RTdHlsZSA9ICgwLCBfdXRpbHMuc2V0UG9zaXRpb24pKC0obGFzdFBvc2l0aW9uICsgMikgKiAxMDAsIHByb3BzLmF4aXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldmlvdXNJdGVtID4gbGFzdFBvc2l0aW9uKSB7XG4gICAgICByZXR1cm5TdHlsZXMuaXRlbUxpc3RTdHlsZSA9ICgwLCBfdXRpbHMuc2V0UG9zaXRpb24pKDAsIHByb3BzLmF4aXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5TdHlsZXM7XG4gIH1cblxuICB2YXIgY3VycmVudFBvc2l0aW9uID0gKDAsIF91dGlscy5nZXRQb3NpdGlvbikoc2VsZWN0ZWRJdGVtLCBwcm9wcyk7IC8vIGlmIDNkIGlzIGF2YWlsYWJsZSwgbGV0J3MgdGFrZSBhZHZhbnRhZ2Ugb2YgdGhlIHBlcmZvcm1hbmNlIG9mIHRyYW5zZm9ybVxuXG4gIHZhciB0cmFuc2Zvcm1Qcm9wID0gKDAsIF9DU1NUcmFuc2xhdGUuZGVmYXVsdCkoY3VycmVudFBvc2l0aW9uLCAnJScsIHByb3BzLmF4aXMpO1xuICB2YXIgdHJhbnNpdGlvblRpbWUgPSBwcm9wcy50cmFuc2l0aW9uVGltZSArICdtcyc7XG4gIHJldHVyblN0eWxlcy5pdGVtTGlzdFN0eWxlID0ge1xuICAgIFdlYmtpdFRyYW5zZm9ybTogdHJhbnNmb3JtUHJvcCxcbiAgICBtc1RyYW5zZm9ybTogdHJhbnNmb3JtUHJvcCxcbiAgICBPVHJhbnNmb3JtOiB0cmFuc2Zvcm1Qcm9wLFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtUHJvcFxuICB9O1xuXG4gIGlmICghc3RhdGUuc3dpcGluZykge1xuICAgIHJldHVyblN0eWxlcy5pdGVtTGlzdFN0eWxlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXR1cm5TdHlsZXMuaXRlbUxpc3RTdHlsZSksIHt9LCB7XG4gICAgICBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25UaW1lLFxuICAgICAgTW96VHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uVGltZSxcbiAgICAgIE9UcmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25UaW1lLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uVGltZSxcbiAgICAgIG1zVHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uVGltZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJldHVyblN0eWxlcztcbn07XG4vKipcbiAqIFN3aXBpbmcgYW5pbWF0aW9uIGhhbmRsZXIgZm9yIHRoZSBkZWZhdWx0ICdzbGlkaW5nJyBzdHlsZSBhbmltYXRpb25cbiAqIEBwYXJhbSBkZWx0YVxuICogQHBhcmFtIHByb3BzXG4gKiBAcGFyYW0gc3RhdGVcbiAqIEBwYXJhbSBzZXRTdGF0ZVxuICovXG5cblxuZXhwb3J0cy5zbGlkZUFuaW1hdGlvbkhhbmRsZXIgPSBzbGlkZUFuaW1hdGlvbkhhbmRsZXI7XG5cbnZhciBzbGlkZVN3aXBlQW5pbWF0aW9uSGFuZGxlciA9IGZ1bmN0aW9uIHNsaWRlU3dpcGVBbmltYXRpb25IYW5kbGVyKGRlbHRhLCBwcm9wcywgc3RhdGUsIHNldFN0YXRlKSB7XG4gIHZhciByZXR1cm5TdHlsZXMgPSB7fTtcbiAgdmFyIGlzSG9yaXpvbnRhbCA9IHByb3BzLmF4aXMgPT09ICdob3Jpem9udGFsJztcblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBfcmVhY3QuQ2hpbGRyZW4uY291bnQocHJvcHMuY2hpbGRyZW4pO1xuXG4gIHZhciBpbml0aWFsQm91bmRyeSA9IDA7XG4gIHZhciBjdXJyZW50UG9zaXRpb24gPSAoMCwgX3V0aWxzLmdldFBvc2l0aW9uKShzdGF0ZS5zZWxlY3RlZEl0ZW0sIHByb3BzKTtcbiAgdmFyIGZpbmFsQm91bmRyeSA9IHByb3BzLmluZmluaXRlTG9vcCA/ICgwLCBfdXRpbHMuZ2V0UG9zaXRpb24pKGNoaWxkcmVuTGVuZ3RoIC0gMSwgcHJvcHMpIC0gMTAwIDogKDAsIF91dGlscy5nZXRQb3NpdGlvbikoY2hpbGRyZW5MZW5ndGggLSAxLCBwcm9wcyk7XG4gIHZhciBheGlzRGVsdGEgPSBpc0hvcml6b250YWwgPyBkZWx0YS54IDogZGVsdGEueTtcbiAgdmFyIGhhbmRsZWREZWx0YSA9IGF4aXNEZWx0YTsgLy8gcHJldmVudCB1c2VyIGZyb20gc3dpcGluZyBsZWZ0IG91dCBvZiBib3VuZGFyaWVzXG5cbiAgaWYgKGN1cnJlbnRQb3NpdGlvbiA9PT0gaW5pdGlhbEJvdW5kcnkgJiYgYXhpc0RlbHRhID4gMCkge1xuICAgIGhhbmRsZWREZWx0YSA9IDA7XG4gIH0gLy8gcHJldmVudCB1c2VyIGZyb20gc3dpcGluZyByaWdodCBvdXQgb2YgYm91bmRhcmllc1xuXG5cbiAgaWYgKGN1cnJlbnRQb3NpdGlvbiA9PT0gZmluYWxCb3VuZHJ5ICYmIGF4aXNEZWx0YSA8IDApIHtcbiAgICBoYW5kbGVkRGVsdGEgPSAwO1xuICB9XG5cbiAgdmFyIHBvc2l0aW9uID0gY3VycmVudFBvc2l0aW9uICsgMTAwIC8gKHN0YXRlLml0ZW1TaXplIC8gaGFuZGxlZERlbHRhKTtcbiAgdmFyIGhhc01vdmVkID0gTWF0aC5hYnMoYXhpc0RlbHRhKSA+IHByb3BzLnN3aXBlU2Nyb2xsVG9sZXJhbmNlO1xuXG4gIGlmIChwcm9wcy5pbmZpbml0ZUxvb3AgJiYgaGFzTW92ZWQpIHtcbiAgICAvLyBXaGVuIGFsbG93aW5nIGluZmluaXRlIGxvb3AsIGlmIHdlIHNsaWRlIGxlZnQgZnJvbSBwb3NpdGlvbiAwIHdlIHJldmVhbCB0aGUgY2xvbmVkIGxhc3Qgc2xpZGUgdGhhdCBhcHBlYXJzIGJlZm9yZSBpdFxuICAgIC8vIGlmIHdlIHNsaWRlIGV2ZW4gZnVydGhlciB3ZSBuZWVkIHRvIGp1bXAgdG8gb3RoZXIgc2lkZSBzbyBpdCBjYW4gY29udGludWUgLSBhbmQgdmljZSB2ZXJzYSBmb3IgdGhlIGxhc3Qgc2xpZGVcbiAgICBpZiAoc3RhdGUuc2VsZWN0ZWRJdGVtID09PSAwICYmIHBvc2l0aW9uID4gLTEwMCkge1xuICAgICAgcG9zaXRpb24gLT0gY2hpbGRyZW5MZW5ndGggKiAxMDA7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5zZWxlY3RlZEl0ZW0gPT09IGNoaWxkcmVuTGVuZ3RoIC0gMSAmJiBwb3NpdGlvbiA8IC1jaGlsZHJlbkxlbmd0aCAqIDEwMCkge1xuICAgICAgcG9zaXRpb24gKz0gY2hpbGRyZW5MZW5ndGggKiAxMDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFwcm9wcy5wcmV2ZW50TW92ZW1lbnRVbnRpbFN3aXBlU2Nyb2xsVG9sZXJhbmNlIHx8IGhhc01vdmVkIHx8IHN0YXRlLnN3aXBlTW92ZW1lbnRTdGFydGVkKSB7XG4gICAgaWYgKCFzdGF0ZS5zd2lwZU1vdmVtZW50U3RhcnRlZCkge1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBzd2lwZU1vdmVtZW50U3RhcnRlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuU3R5bGVzLml0ZW1MaXN0U3R5bGUgPSAoMCwgX3V0aWxzLnNldFBvc2l0aW9uKShwb3NpdGlvbiwgcHJvcHMuYXhpcyk7XG4gIH0gLy9hbGxvd3Mgc2Nyb2xsIGlmIHRoZSBzd2lwZSB3YXMgd2l0aGluIHRoZSB0b2xlcmFuY2VcblxuXG4gIGlmIChoYXNNb3ZlZCAmJiAhc3RhdGUuY2FuY2VsQ2xpY2spIHtcbiAgICBzZXRTdGF0ZSh7XG4gICAgICBjYW5jZWxDbGljazogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJldHVyblN0eWxlcztcbn07XG4vKipcbiAqIERlZmF1bHQgJ3NsaWRpbmcnIHN0eWxlIGFuaW1pbmF0aW9uIGhhbmRsZXIgZm9yIHdoZW4gYSBzd2lwZSBhY3Rpb24gc3RvcHMuXG4gKiBAcGFyYW0gcHJvcHNcbiAqIEBwYXJhbSBzdGF0ZVxuICovXG5cblxuZXhwb3J0cy5zbGlkZVN3aXBlQW5pbWF0aW9uSGFuZGxlciA9IHNsaWRlU3dpcGVBbmltYXRpb25IYW5kbGVyO1xuXG52YXIgc2xpZGVTdG9wU3dpcGluZ0hhbmRsZXIgPSBmdW5jdGlvbiBzbGlkZVN0b3BTd2lwaW5nSGFuZGxlcihwcm9wcywgc3RhdGUpIHtcbiAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9ICgwLCBfdXRpbHMuZ2V0UG9zaXRpb24pKHN0YXRlLnNlbGVjdGVkSXRlbSwgcHJvcHMpO1xuICB2YXIgaXRlbUxpc3RTdHlsZSA9ICgwLCBfdXRpbHMuc2V0UG9zaXRpb24pKGN1cnJlbnRQb3NpdGlvbiwgcHJvcHMuYXhpcyk7XG4gIHJldHVybiB7XG4gICAgaXRlbUxpc3RTdHlsZTogaXRlbUxpc3RTdHlsZVxuICB9O1xufTtcbi8qKlxuICogTWFpbiBhbmltYXRpb24gaGFuZGxlciBmb3IgdGhlIGRlZmF1bHQgJ2ZhZGUnIHN0eWxlIGFuaW1hdGlvblxuICogQHBhcmFtIHByb3BzXG4gKiBAcGFyYW0gc3RhdGVcbiAqL1xuXG5cbmV4cG9ydHMuc2xpZGVTdG9wU3dpcGluZ0hhbmRsZXIgPSBzbGlkZVN0b3BTd2lwaW5nSGFuZGxlcjtcblxudmFyIGZhZGVBbmltYXRpb25IYW5kbGVyID0gZnVuY3Rpb24gZmFkZUFuaW1hdGlvbkhhbmRsZXIocHJvcHMsIHN0YXRlKSB7XG4gIHZhciB0cmFuc2l0aW9uVGltZSA9IHByb3BzLnRyYW5zaXRpb25UaW1lICsgJ21zJztcbiAgdmFyIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9ICdlYXNlLWluLW91dCc7XG4gIHZhciBzbGlkZVN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgekluZGV4OiAtMixcbiAgICBtaW5IZWlnaHQ6ICcxMDAlJyxcbiAgICBvcGFjaXR5OiAwLFxuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbixcbiAgICBtc1RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uLFxuICAgIE1velRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uLFxuICAgIFdlYmtpdFRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uLFxuICAgIE9UcmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvblxuICB9O1xuXG4gIGlmICghc3RhdGUuc3dpcGluZykge1xuICAgIHNsaWRlU3R5bGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNsaWRlU3R5bGUpLCB7fSwge1xuICAgICAgV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uVGltZSxcbiAgICAgIE1velRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvblRpbWUsXG4gICAgICBPVHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uVGltZSxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvblRpbWUsXG4gICAgICBtc1RyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvblRpbWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2xpZGVTdHlsZTogc2xpZGVTdHlsZSxcbiAgICBzZWxlY3RlZFN0eWxlOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNsaWRlU3R5bGUpLCB7fSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgfSksXG4gICAgcHJldlN0eWxlOiBfb2JqZWN0U3ByZWFkKHt9LCBzbGlkZVN0eWxlKVxuICB9O1xufTtcblxuZXhwb3J0cy5mYWRlQW5pbWF0aW9uSGFuZGxlciA9IGZhZGVBbmltYXRpb25IYW5kbGVyOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-responsive-carousel/lib/js/components/Carousel/animations.js\n");

/***/ }),

/***/ "./node_modules/react-responsive-carousel/lib/js/components/Carousel/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/react-responsive-carousel/lib/js/components/Carousel/index.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _reactEasySwipe = _interopRequireDefault(__webpack_require__(/*! react-easy-swipe */ \"./node_modules/react-easy-swipe/lib/index.js\"));\n\nvar _cssClasses = _interopRequireDefault(__webpack_require__(/*! ../../cssClasses */ \"./node_modules/react-responsive-carousel/lib/js/cssClasses.js\"));\n\nvar _Thumbs = _interopRequireDefault(__webpack_require__(/*! ../Thumbs */ \"./node_modules/react-responsive-carousel/lib/js/components/Thumbs.js\"));\n\nvar _document = _interopRequireDefault(__webpack_require__(/*! ../../shims/document */ \"./node_modules/react-responsive-carousel/lib/js/shims/document.js\"));\n\nvar _window = _interopRequireDefault(__webpack_require__(/*! ../../shims/window */ \"./node_modules/react-responsive-carousel/lib/js/shims/window.js\"));\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./node_modules/react-responsive-carousel/lib/js/components/Carousel/utils.js\");\n\nvar _animations = __webpack_require__(/*! ./animations */ \"./node_modules/react-responsive-carousel/lib/js/components/Carousel/animations.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar Carousel = /*#__PURE__*/function (_React$Component) {\n  _inherits(Carousel, _React$Component);\n\n  var _super = _createSuper(Carousel);\n\n  // @ts-ignore\n  function Carousel(props) {\n    var _this;\n\n    _classCallCheck(this, Carousel);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"thumbsRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"carouselWrapperRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"listRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"itemsRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"timer\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"animationHandler\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"setThumbsRef\", function (node) {\n      _this.thumbsRef = node;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setCarouselWrapperRef\", function (node) {\n      _this.carouselWrapperRef = node;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setListRef\", function (node) {\n      _this.listRef = node;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setItemsRef\", function (node, index) {\n      if (!_this.itemsRef) {\n        _this.itemsRef = [];\n      }\n\n      _this.itemsRef[index] = node;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"autoPlay\", function () {\n      if (_react.Children.count(_this.props.children) <= 1) {\n        return;\n      }\n\n      _this.clearAutoPlay();\n\n      if (!_this.props.autoPlay) {\n        return;\n      }\n\n      _this.timer = setTimeout(function () {\n        _this.increment();\n      }, _this.props.interval);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"clearAutoPlay\", function () {\n      if (_this.timer) clearTimeout(_this.timer);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"resetAutoPlay\", function () {\n      _this.clearAutoPlay();\n\n      _this.autoPlay();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"stopOnHover\", function () {\n      _this.setState({\n        isMouseEntered: true\n      }, _this.clearAutoPlay);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"startOnLeave\", function () {\n      _this.setState({\n        isMouseEntered: false\n      }, _this.autoPlay);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"isFocusWithinTheCarousel\", function () {\n      if (!_this.carouselWrapperRef) {\n        return false;\n      }\n\n      if ((0, _document.default)().activeElement === _this.carouselWrapperRef || _this.carouselWrapperRef.contains((0, _document.default)().activeElement)) {\n        return true;\n      }\n\n      return false;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"navigateWithKeyboard\", function (e) {\n      if (!_this.isFocusWithinTheCarousel()) {\n        return;\n      }\n\n      var axis = _this.props.axis;\n      var isHorizontal = axis === 'horizontal';\n      var keyNames = {\n        ArrowUp: 38,\n        ArrowRight: 39,\n        ArrowDown: 40,\n        ArrowLeft: 37\n      };\n      var nextKey = isHorizontal ? keyNames.ArrowRight : keyNames.ArrowDown;\n      var prevKey = isHorizontal ? keyNames.ArrowLeft : keyNames.ArrowUp;\n\n      if (nextKey === e.keyCode) {\n        _this.increment();\n      } else if (prevKey === e.keyCode) {\n        _this.decrement();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"updateSizes\", function () {\n      if (!_this.state.initialized || !_this.itemsRef || _this.itemsRef.length === 0) {\n        return;\n      }\n\n      var isHorizontal = _this.props.axis === 'horizontal';\n      var firstItem = _this.itemsRef[0];\n\n      if (!firstItem) {\n        return;\n      }\n\n      var itemSize = isHorizontal ? firstItem.clientWidth : firstItem.clientHeight;\n\n      _this.setState({\n        itemSize: itemSize\n      });\n\n      if (_this.thumbsRef) {\n        _this.thumbsRef.updateSizes();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setMountState\", function () {\n      _this.setState({\n        hasMount: true\n      });\n\n      _this.updateSizes();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleClickItem\", function (index, item) {\n      if (_react.Children.count(_this.props.children) === 0) {\n        return;\n      }\n\n      if (_this.state.cancelClick) {\n        _this.setState({\n          cancelClick: false\n        });\n\n        return;\n      }\n\n      _this.props.onClickItem(index, item);\n\n      if (index !== _this.state.selectedItem) {\n        _this.setState({\n          selectedItem: index\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleOnChange\", function (index, item) {\n      if (_react.Children.count(_this.props.children) <= 1) {\n        return;\n      }\n\n      _this.props.onChange(index, item);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleClickThumb\", function (index, item) {\n      _this.props.onClickThumb(index, item);\n\n      _this.moveTo(index);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onSwipeStart\", function (event) {\n      _this.setState({\n        swiping: true\n      });\n\n      _this.props.onSwipeStart(event);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onSwipeEnd\", function (event) {\n      _this.setState({\n        swiping: false,\n        cancelClick: false,\n        swipeMovementStarted: false\n      });\n\n      _this.props.onSwipeEnd(event);\n\n      _this.clearAutoPlay();\n\n      if (_this.state.autoPlay) {\n        _this.autoPlay();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onSwipeMove\", function (delta, event) {\n      _this.props.onSwipeMove(event);\n\n      var animationHandlerResponse = _this.props.swipeAnimationHandler(delta, _this.props, _this.state, _this.setState.bind(_assertThisInitialized(_this)));\n\n      _this.setState(_objectSpread({}, animationHandlerResponse)); // If we have not moved, we should have an empty object returned\n      // Return false to allow scrolling when not swiping\n\n\n      return !!Object.keys(animationHandlerResponse).length;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"decrement\", function () {\n      var positions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      _this.moveTo(_this.state.selectedItem - (typeof positions === 'number' ? positions : 1));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"increment\", function () {\n      var positions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      _this.moveTo(_this.state.selectedItem + (typeof positions === 'number' ? positions : 1));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"moveTo\", function (position) {\n      if (typeof position !== 'number') {\n        return;\n      }\n\n      var lastPosition = _react.Children.count(_this.props.children) - 1;\n\n      if (position < 0) {\n        position = _this.props.infiniteLoop ? lastPosition : 0;\n      }\n\n      if (position > lastPosition) {\n        position = _this.props.infiniteLoop ? 0 : lastPosition;\n      }\n\n      _this.selectItem({\n        // if it's not a slider, we don't need to set position here\n        selectedItem: position\n      }); // don't reset auto play when stop on hover is enabled, doing so will trigger a call to auto play more than once\n      // and will result in the interval function not being cleared correctly.\n\n\n      if (_this.state.autoPlay && _this.state.isMouseEntered === false) {\n        _this.resetAutoPlay();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onClickNext\", function () {\n      _this.increment(1);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onClickPrev\", function () {\n      _this.decrement(1);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onSwipeForward\", function () {\n      _this.increment(1);\n\n      if (_this.props.emulateTouch) {\n        _this.setState({\n          cancelClick: true\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onSwipeBackwards\", function () {\n      _this.decrement(1);\n\n      if (_this.props.emulateTouch) {\n        _this.setState({\n          cancelClick: true\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"changeItem\", function (newIndex) {\n      return function (e) {\n        if (!(0, _utils.isKeyboardEvent)(e) || e.key === 'Enter') {\n          _this.moveTo(newIndex);\n        }\n      };\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"selectItem\", function (state) {\n      // Merge in the new state while updating updating previous item\n      _this.setState(_objectSpread({\n        previousItem: _this.state.selectedItem\n      }, state), function () {\n        // Run animation handler and update styles based on it\n        _this.setState(_this.animationHandler(_this.props, _this.state));\n      });\n\n      _this.handleOnChange(state.selectedItem, _react.Children.toArray(_this.props.children)[state.selectedItem]);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getInitialImage\", function () {\n      var selectedItem = _this.props.selectedItem;\n      var item = _this.itemsRef && _this.itemsRef[selectedItem];\n      var images = item && item.getElementsByTagName('img') || [];\n      return images[0];\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getVariableItemHeight\", function (position) {\n      var item = _this.itemsRef && _this.itemsRef[position];\n\n      if (_this.state.hasMount && item && item.children.length) {\n        var slideImages = item.children[0].getElementsByTagName('img') || [];\n\n        if (slideImages.length > 0) {\n          var image = slideImages[0];\n\n          if (!image.complete) {\n            // if the image is still loading, the size won't be available so we trigger a new render after it's done\n            var onImageLoad = function onImageLoad() {\n              _this.forceUpdate();\n\n              image.removeEventListener('load', onImageLoad);\n            };\n\n            image.addEventListener('load', onImageLoad);\n          }\n        } // try to get img first, if img not there find first display tag\n\n\n        var displayItem = slideImages[0] || item.children[0];\n        var height = displayItem.clientHeight;\n        return height > 0 ? height : null;\n      }\n\n      return null;\n    });\n\n    var initState = {\n      initialized: false,\n      previousItem: props.selectedItem,\n      selectedItem: props.selectedItem,\n      hasMount: false,\n      isMouseEntered: false,\n      autoPlay: props.autoPlay,\n      swiping: false,\n      swipeMovementStarted: false,\n      cancelClick: false,\n      itemSize: 1,\n      itemListStyle: {},\n      slideStyle: {},\n      selectedStyle: {},\n      prevStyle: {}\n    };\n    _this.animationHandler = typeof props.animationHandler === 'function' && props.animationHandler || props.animationHandler === 'fade' && _animations.fadeAnimationHandler || _animations.slideAnimationHandler;\n    _this.state = _objectSpread(_objectSpread({}, initState), _this.animationHandler(props, initState));\n    return _this;\n  }\n\n  _createClass(Carousel, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (!this.props.children) {\n        return;\n      }\n\n      this.setupCarousel();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      if (!prevProps.children && this.props.children && !this.state.initialized) {\n        this.setupCarousel();\n      }\n\n      if (!prevProps.autoFocus && this.props.autoFocus) {\n        this.forceFocus();\n      }\n\n      if (prevState.swiping && !this.state.swiping) {\n        // We stopped swiping, ensure we are heading to the new/current slide and not stuck\n        this.setState(_objectSpread({}, this.props.stopSwipingHandler(this.props, this.state)));\n      }\n\n      if (prevProps.selectedItem !== this.props.selectedItem || prevProps.centerMode !== this.props.centerMode) {\n        this.updateSizes();\n        this.moveTo(this.props.selectedItem);\n      }\n\n      if (prevProps.autoPlay !== this.props.autoPlay) {\n        if (this.props.autoPlay) {\n          this.setupAutoPlay();\n        } else {\n          this.destroyAutoPlay();\n        }\n\n        this.setState({\n          autoPlay: this.props.autoPlay\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.destroyCarousel();\n    }\n  }, {\n    key: \"setupCarousel\",\n    value: function setupCarousel() {\n      var _this2 = this;\n\n      this.bindEvents();\n\n      if (this.state.autoPlay && _react.Children.count(this.props.children) > 1) {\n        this.setupAutoPlay();\n      }\n\n      if (this.props.autoFocus) {\n        this.forceFocus();\n      }\n\n      this.setState({\n        initialized: true\n      }, function () {\n        var initialImage = _this2.getInitialImage();\n\n        if (initialImage && !initialImage.complete) {\n          // if it's a carousel of images, we set the mount state after the first image is loaded\n          initialImage.addEventListener('load', _this2.setMountState);\n        } else {\n          _this2.setMountState();\n        }\n      });\n    }\n  }, {\n    key: \"destroyCarousel\",\n    value: function destroyCarousel() {\n      if (this.state.initialized) {\n        this.unbindEvents();\n        this.destroyAutoPlay();\n      }\n    }\n  }, {\n    key: \"setupAutoPlay\",\n    value: function setupAutoPlay() {\n      this.autoPlay();\n      var carouselWrapper = this.carouselWrapperRef;\n\n      if (this.props.stopOnHover && carouselWrapper) {\n        carouselWrapper.addEventListener('mouseenter', this.stopOnHover);\n        carouselWrapper.addEventListener('mouseleave', this.startOnLeave);\n      }\n    }\n  }, {\n    key: \"destroyAutoPlay\",\n    value: function destroyAutoPlay() {\n      this.clearAutoPlay();\n      var carouselWrapper = this.carouselWrapperRef;\n\n      if (this.props.stopOnHover && carouselWrapper) {\n        carouselWrapper.removeEventListener('mouseenter', this.stopOnHover);\n        carouselWrapper.removeEventListener('mouseleave', this.startOnLeave);\n      }\n    }\n  }, {\n    key: \"bindEvents\",\n    value: function bindEvents() {\n      // as the widths are calculated, we need to resize\n      // the carousel when the window is resized\n      (0, _window.default)().addEventListener('resize', this.updateSizes); // issue #2 - image loading smaller\n\n      (0, _window.default)().addEventListener('DOMContentLoaded', this.updateSizes);\n\n      if (this.props.useKeyboardArrows) {\n        (0, _document.default)().addEventListener('keydown', this.navigateWithKeyboard);\n      }\n    }\n  }, {\n    key: \"unbindEvents\",\n    value: function unbindEvents() {\n      // removing listeners\n      (0, _window.default)().removeEventListener('resize', this.updateSizes);\n      (0, _window.default)().removeEventListener('DOMContentLoaded', this.updateSizes);\n      var initialImage = this.getInitialImage();\n\n      if (initialImage) {\n        initialImage.removeEventListener('load', this.setMountState);\n      }\n\n      if (this.props.useKeyboardArrows) {\n        (0, _document.default)().removeEventListener('keydown', this.navigateWithKeyboard);\n      }\n    }\n  }, {\n    key: \"forceFocus\",\n    value: function forceFocus() {\n      var _this$carouselWrapper;\n\n      (_this$carouselWrapper = this.carouselWrapperRef) === null || _this$carouselWrapper === void 0 ? void 0 : _this$carouselWrapper.focus();\n    }\n  }, {\n    key: \"renderItems\",\n    value: function renderItems(isClone) {\n      var _this3 = this;\n\n      if (!this.props.children) {\n        return [];\n      }\n\n      return _react.Children.map(this.props.children, function (item, index) {\n        var isSelected = index === _this3.state.selectedItem;\n        var isPrevious = index === _this3.state.previousItem;\n        var style = isSelected && _this3.state.selectedStyle || isPrevious && _this3.state.prevStyle || _this3.state.slideStyle || {};\n\n        if (_this3.props.centerMode && _this3.props.axis === 'horizontal') {\n          style = _objectSpread(_objectSpread({}, style), {}, {\n            minWidth: _this3.props.centerSlidePercentage + '%'\n          });\n        }\n\n        if (_this3.state.swiping && _this3.state.swipeMovementStarted) {\n          style = _objectSpread(_objectSpread({}, style), {}, {\n            pointerEvents: 'none'\n          });\n        }\n\n        var slideProps = {\n          ref: function ref(e) {\n            return _this3.setItemsRef(e, index);\n          },\n          key: 'itemKey' + index + (isClone ? 'clone' : ''),\n          className: _cssClasses.default.ITEM(true, index === _this3.state.selectedItem, index === _this3.state.previousItem),\n          onClick: _this3.handleClickItem.bind(_this3, index, item),\n          style: style\n        };\n        return /*#__PURE__*/_react.default.createElement(\"li\", slideProps, _this3.props.renderItem(item, {\n          isSelected: index === _this3.state.selectedItem,\n          isPrevious: index === _this3.state.previousItem\n        }));\n      });\n    }\n  }, {\n    key: \"renderControls\",\n    value: function renderControls() {\n      var _this4 = this;\n\n      var _this$props = this.props,\n          showIndicators = _this$props.showIndicators,\n          labels = _this$props.labels,\n          renderIndicator = _this$props.renderIndicator,\n          children = _this$props.children;\n\n      if (!showIndicators) {\n        return null;\n      }\n\n      return /*#__PURE__*/_react.default.createElement(\"ul\", {\n        className: \"control-dots\"\n      }, _react.Children.map(children, function (_, index) {\n        return renderIndicator && renderIndicator(_this4.changeItem(index), index === _this4.state.selectedItem, index, labels.item);\n      }));\n    }\n  }, {\n    key: \"renderStatus\",\n    value: function renderStatus() {\n      if (!this.props.showStatus) {\n        return null;\n      }\n\n      return /*#__PURE__*/_react.default.createElement(\"p\", {\n        className: \"carousel-status\"\n      }, this.props.statusFormatter(this.state.selectedItem + 1, _react.Children.count(this.props.children)));\n    }\n  }, {\n    key: \"renderThumbs\",\n    value: function renderThumbs() {\n      if (!this.props.showThumbs || !this.props.children || _react.Children.count(this.props.children) === 0) {\n        return null;\n      }\n\n      return /*#__PURE__*/_react.default.createElement(_Thumbs.default, {\n        ref: this.setThumbsRef,\n        onSelectItem: this.handleClickThumb,\n        selectedItem: this.state.selectedItem,\n        transitionTime: this.props.transitionTime,\n        thumbWidth: this.props.thumbWidth,\n        labels: this.props.labels,\n        emulateTouch: this.props.emulateTouch\n      }, this.props.renderThumbs(this.props.children));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      if (!this.props.children || _react.Children.count(this.props.children) === 0) {\n        return null;\n      }\n\n      var isSwipeable = this.props.swipeable && _react.Children.count(this.props.children) > 1;\n      var isHorizontal = this.props.axis === 'horizontal';\n      var canShowArrows = this.props.showArrows && _react.Children.count(this.props.children) > 1; // show left arrow?\n\n      var hasPrev = canShowArrows && (this.state.selectedItem > 0 || this.props.infiniteLoop) || false; // show right arrow\n\n      var hasNext = canShowArrows && (this.state.selectedItem < _react.Children.count(this.props.children) - 1 || this.props.infiniteLoop) || false;\n      var itemsClone = this.renderItems(true);\n      var firstClone = itemsClone.shift();\n      var lastClone = itemsClone.pop();\n      var swiperProps = {\n        className: _cssClasses.default.SLIDER(true, this.state.swiping),\n        onSwipeMove: this.onSwipeMove,\n        onSwipeStart: this.onSwipeStart,\n        onSwipeEnd: this.onSwipeEnd,\n        style: this.state.itemListStyle,\n        tolerance: this.props.swipeScrollTolerance\n      };\n      var containerStyles = {};\n\n      if (isHorizontal) {\n        swiperProps.onSwipeLeft = this.onSwipeForward;\n        swiperProps.onSwipeRight = this.onSwipeBackwards;\n\n        if (this.props.dynamicHeight) {\n          var itemHeight = this.getVariableItemHeight(this.state.selectedItem); // swiperProps.style.height = itemHeight || 'auto';\n\n          containerStyles.height = itemHeight || 'auto';\n        }\n      } else {\n        swiperProps.onSwipeUp = this.props.verticalSwipe === 'natural' ? this.onSwipeBackwards : this.onSwipeForward;\n        swiperProps.onSwipeDown = this.props.verticalSwipe === 'natural' ? this.onSwipeForward : this.onSwipeBackwards;\n        swiperProps.style = _objectSpread(_objectSpread({}, swiperProps.style), {}, {\n          height: this.state.itemSize\n        });\n        containerStyles.height = this.state.itemSize;\n      }\n\n      return /*#__PURE__*/_react.default.createElement(\"div\", {\n        \"aria-label\": this.props.ariaLabel,\n        className: _cssClasses.default.ROOT(this.props.className),\n        ref: this.setCarouselWrapperRef,\n        tabIndex: this.props.useKeyboardArrows ? 0 : undefined\n      }, /*#__PURE__*/_react.default.createElement(\"div\", {\n        className: _cssClasses.default.CAROUSEL(true),\n        style: {\n          width: this.props.width\n        }\n      }, this.renderControls(), this.props.renderArrowPrev(this.onClickPrev, hasPrev, this.props.labels.leftArrow), /*#__PURE__*/_react.default.createElement(\"div\", {\n        className: _cssClasses.default.WRAPPER(true, this.props.axis),\n        style: containerStyles\n      }, isSwipeable ? /*#__PURE__*/_react.default.createElement(_reactEasySwipe.default, _extends({\n        tagName: \"ul\",\n        innerRef: this.setListRef\n      }, swiperProps, {\n        allowMouseEvents: this.props.emulateTouch\n      }), this.props.infiniteLoop && lastClone, this.renderItems(), this.props.infiniteLoop && firstClone) : /*#__PURE__*/_react.default.createElement(\"ul\", {\n        className: _cssClasses.default.SLIDER(true, this.state.swiping),\n        ref: function ref(node) {\n          return _this5.setListRef(node);\n        },\n        style: this.state.itemListStyle || {}\n      }, this.props.infiniteLoop && lastClone, this.renderItems(), this.props.infiniteLoop && firstClone)), this.props.renderArrowNext(this.onClickNext, hasNext, this.props.labels.rightArrow), this.renderStatus()), this.renderThumbs());\n    }\n  }]);\n\n  return Carousel;\n}(_react.default.Component);\n\nexports.default = Carousel;\n\n_defineProperty(Carousel, \"displayName\", 'Carousel');\n\n_defineProperty(Carousel, \"defaultProps\", {\n  ariaLabel: undefined,\n  axis: 'horizontal',\n  centerSlidePercentage: 80,\n  interval: 3000,\n  labels: {\n    leftArrow: 'previous slide / item',\n    rightArrow: 'next slide / item',\n    item: 'slide item'\n  },\n  onClickItem: _utils.noop,\n  onClickThumb: _utils.noop,\n  onChange: _utils.noop,\n  onSwipeStart: function onSwipeStart() {},\n  onSwipeEnd: function onSwipeEnd() {},\n  onSwipeMove: function onSwipeMove() {\n    return false;\n  },\n  preventMovementUntilSwipeScrollTolerance: false,\n  renderArrowPrev: function renderArrowPrev(onClickHandler, hasPrev, label) {\n    return /*#__PURE__*/_react.default.createElement(\"button\", {\n      type: \"button\",\n      \"aria-label\": label,\n      className: _cssClasses.default.ARROW_PREV(!hasPrev),\n      onClick: onClickHandler\n    });\n  },\n  renderArrowNext: function renderArrowNext(onClickHandler, hasNext, label) {\n    return /*#__PURE__*/_react.default.createElement(\"button\", {\n      type: \"button\",\n      \"aria-label\": label,\n      className: _cssClasses.default.ARROW_NEXT(!hasNext),\n      onClick: onClickHandler\n    });\n  },\n  renderIndicator: function renderIndicator(onClickHandler, isSelected, index, label) {\n    return /*#__PURE__*/_react.default.createElement(\"li\", {\n      className: _cssClasses.default.DOT(isSelected),\n      onClick: onClickHandler,\n      onKeyDown: onClickHandler,\n      value: index,\n      key: index,\n      role: \"button\",\n      tabIndex: 0,\n      \"aria-label\": \"\".concat(label, \" \").concat(index + 1)\n    });\n  },\n  renderItem: function renderItem(item) {\n    return item;\n  },\n  renderThumbs: function renderThumbs(children) {\n    var images = _react.Children.map(children, function (item) {\n      var img = item; // if the item is not an image, try to find the first image in the item's children.\n\n      if (item.type !== 'img') {\n        img = _react.Children.toArray(item.props.children).find(function (children) {\n          return children.type === 'img';\n        });\n      }\n\n      if (!img) {\n        return undefined;\n      }\n\n      return img;\n    });\n\n    if (images.filter(function (image) {\n      return image;\n    }).length === 0) {\n      console.warn(\"No images found! Can't build the thumb list without images. If you don't need thumbs, set showThumbs={false} in the Carousel. Note that it's not possible to get images rendered inside custom components. More info at https://github.com/leandrowd/react-responsive-carousel/blob/master/TROUBLESHOOTING.md\");\n      return [];\n    }\n\n    return images;\n  },\n  statusFormatter: _utils.defaultStatusFormatter,\n  selectedItem: 0,\n  showArrows: true,\n  showIndicators: true,\n  showStatus: true,\n  showThumbs: true,\n  stopOnHover: true,\n  swipeScrollTolerance: 5,\n  swipeable: true,\n  transitionTime: 350,\n  verticalSwipe: 'standard',\n  width: '100%',\n  animationHandler: 'slide',\n  swipeAnimationHandler: _animations.slideSwipeAnimationHandler,\n  stopSwipingHandler: _animations.slideStopSwipingHandler\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2pzL2NvbXBvbmVudHMvQ2Fyb3VzZWwvaW5kZXguanM/ZjNjOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixlQUFlOztBQUVmLHFDQUFxQyxtQkFBTyxDQUFDLDRDQUFPOztBQUVwRCw2Q0FBNkMsbUJBQU8sQ0FBQyxzRUFBa0I7O0FBRXZFLHlDQUF5QyxtQkFBTyxDQUFDLHVGQUFrQjs7QUFFbkUscUNBQXFDLG1CQUFPLENBQUMsdUZBQVc7O0FBRXhELHVDQUF1QyxtQkFBTyxDQUFDLCtGQUFzQjs7QUFFckUscUNBQXFDLG1CQUFPLENBQUMsMkZBQW9COztBQUVqRSxhQUFhLG1CQUFPLENBQUMsNkZBQVM7O0FBRTlCLGtCQUFrQixtQkFBTyxDQUFDLHVHQUFjOztBQUV4QyxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0YscUNBQXFDLGdEQUFnRCwyQkFBMkIsaUVBQWlFLGNBQWMsR0FBRyxjQUFjOztBQUVoTix1Q0FBdUMsNkJBQTZCLFlBQVksRUFBRSw4RUFBOEUsU0FBUyxnQkFBZ0IsRUFBRSx3Q0FBd0MsK0JBQStCLHVCQUF1QixFQUFFLGlCQUFpQixzRkFBc0YsdUJBQXVCLHNEQUFzRCxxRkFBcUYsc0NBQXNDLDBDQUEwQyxFQUFFLE9BQU8sd0JBQXdCLEVBQUUsRUFBRSxFQUFFLHNCQUFzQixhQUFhLHdCQUF3QixFQUFFLGVBQWU7O0FBRXZ1Qix1QkFBdUIsMkJBQTJCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFeFgscUJBQXFCLGdEQUFnRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWUsR0FBRyx3Q0FBd0M7O0FBRTNULDBDQUEwQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw4REFBOEQsZ0VBQWdFLEVBQUUsRUFBRSxnQ0FBZ0MsRUFBRSxhQUFhOztBQUVuVixnQ0FBZ0MsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHVEQUF1RCwyQ0FBMkMsRUFBRSxFQUFFLEVBQUUsNkNBQTZDLDJFQUEyRSxFQUFFLE9BQU8saURBQWlELGtGQUFrRixFQUFFLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRXBoQixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTiwwQ0FBMEMsK0RBQStELDJFQUEyRSxFQUFFLHlFQUF5RSxlQUFlLHNEQUFzRCxFQUFFLEVBQUUsdURBQXVEOztBQUUvWCxnQ0FBZ0MsNEVBQTRFLGlCQUFpQixVQUFVLEdBQUcsOEJBQThCOztBQUV4SyxnQ0FBZ0MsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCx5REFBeUQsRUFBRSxPQUFPLHVDQUF1QyxFQUFFLGlEQUFpRCxHQUFHOztBQUV2YSxpREFBaUQsMEVBQTBFLGFBQWEsRUFBRSxxQ0FBcUM7O0FBRS9LLHVDQUF1Qyx1QkFBdUIsdUZBQXVGLEVBQUUsYUFBYTs7QUFFcEssc0NBQXNDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sd0VBQXdFLEdBQUcsYUFBYSxFQUFFLFlBQVksY0FBYyxFQUFFOztBQUVsVSw2QkFBNkIsZ0dBQWdHLGdEQUFnRCxHQUFHLDJCQUEyQjs7QUFFM00sMkNBQTJDLGtCQUFrQixrQ0FBa0MscUVBQXFFLEVBQUUsRUFBRSxPQUFPLGtCQUFrQixFQUFFLFlBQVk7O0FBRS9NO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUEscUNBQXFDLDZCQUE2QjtBQUNsRTs7O0FBR0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFOztBQUUxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtHQUFrRzs7QUFFbEcsdUdBQXVHOztBQUV2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrRUFBK0U7O0FBRS9FO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDBEQUEwRCx3QkFBd0I7QUFDbEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCxlQUFlOztBQUVmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTCwwSEFBMEgsTUFBTTtBQUNoSTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS1jYXJvdXNlbC9saWIvanMvY29tcG9uZW50cy9DYXJvdXNlbC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9yZWFjdEVhc3lTd2lwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LWVhc3ktc3dpcGVcIikpO1xuXG52YXIgX2Nzc0NsYXNzZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9jc3NDbGFzc2VzXCIpKTtcblxudmFyIF9UaHVtYnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9UaHVtYnNcIikpO1xuXG52YXIgX2RvY3VtZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vc2hpbXMvZG9jdW1lbnRcIikpO1xuXG52YXIgX3dpbmRvdyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3NoaW1zL3dpbmRvd1wiKSk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxudmFyIF9hbmltYXRpb25zID0gcmVxdWlyZShcIi4vYW5pbWF0aW9uc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIENhcm91c2VsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhDYXJvdXNlbCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDYXJvdXNlbCk7XG5cbiAgLy8gQHRzLWlnbm9yZVxuICBmdW5jdGlvbiBDYXJvdXNlbChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXJvdXNlbCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ0aHVtYnNSZWZcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjYXJvdXNlbFdyYXBwZXJSZWZcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJsaXN0UmVmXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaXRlbXNSZWZcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ0aW1lclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImFuaW1hdGlvbkhhbmRsZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzZXRUaHVtYnNSZWZcIiwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIF90aGlzLnRodW1ic1JlZiA9IG5vZGU7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2V0Q2Fyb3VzZWxXcmFwcGVyUmVmXCIsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBfdGhpcy5jYXJvdXNlbFdyYXBwZXJSZWYgPSBub2RlO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNldExpc3RSZWZcIiwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIF90aGlzLmxpc3RSZWYgPSBub2RlO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNldEl0ZW1zUmVmXCIsIGZ1bmN0aW9uIChub2RlLCBpbmRleCkge1xuICAgICAgaWYgKCFfdGhpcy5pdGVtc1JlZikge1xuICAgICAgICBfdGhpcy5pdGVtc1JlZiA9IFtdO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5pdGVtc1JlZltpbmRleF0gPSBub2RlO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImF1dG9QbGF5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfcmVhY3QuQ2hpbGRyZW4uY291bnQoX3RoaXMucHJvcHMuY2hpbGRyZW4pIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jbGVhckF1dG9QbGF5KCk7XG5cbiAgICAgIGlmICghX3RoaXMucHJvcHMuYXV0b1BsYXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5pbmNyZW1lbnQoKTtcbiAgICAgIH0sIF90aGlzLnByb3BzLmludGVydmFsKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjbGVhckF1dG9QbGF5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy50aW1lcikgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVyKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJyZXNldEF1dG9QbGF5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNsZWFyQXV0b1BsYXkoKTtcblxuICAgICAgX3RoaXMuYXV0b1BsYXkoKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzdG9wT25Ib3ZlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzTW91c2VFbnRlcmVkOiB0cnVlXG4gICAgICB9LCBfdGhpcy5jbGVhckF1dG9QbGF5KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzdGFydE9uTGVhdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc01vdXNlRW50ZXJlZDogZmFsc2VcbiAgICAgIH0sIF90aGlzLmF1dG9QbGF5KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJpc0ZvY3VzV2l0aGluVGhlQ2Fyb3VzZWxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5jYXJvdXNlbFdyYXBwZXJSZWYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKDAsIF9kb2N1bWVudC5kZWZhdWx0KSgpLmFjdGl2ZUVsZW1lbnQgPT09IF90aGlzLmNhcm91c2VsV3JhcHBlclJlZiB8fCBfdGhpcy5jYXJvdXNlbFdyYXBwZXJSZWYuY29udGFpbnMoKDAsIF9kb2N1bWVudC5kZWZhdWx0KSgpLmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibmF2aWdhdGVXaXRoS2V5Ym9hcmRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghX3RoaXMuaXNGb2N1c1dpdGhpblRoZUNhcm91c2VsKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXhpcyA9IF90aGlzLnByb3BzLmF4aXM7XG4gICAgICB2YXIgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ2hvcml6b250YWwnO1xuICAgICAgdmFyIGtleU5hbWVzID0ge1xuICAgICAgICBBcnJvd1VwOiAzOCxcbiAgICAgICAgQXJyb3dSaWdodDogMzksXG4gICAgICAgIEFycm93RG93bjogNDAsXG4gICAgICAgIEFycm93TGVmdDogMzdcbiAgICAgIH07XG4gICAgICB2YXIgbmV4dEtleSA9IGlzSG9yaXpvbnRhbCA/IGtleU5hbWVzLkFycm93UmlnaHQgOiBrZXlOYW1lcy5BcnJvd0Rvd247XG4gICAgICB2YXIgcHJldktleSA9IGlzSG9yaXpvbnRhbCA/IGtleU5hbWVzLkFycm93TGVmdCA6IGtleU5hbWVzLkFycm93VXA7XG5cbiAgICAgIGlmIChuZXh0S2V5ID09PSBlLmtleUNvZGUpIHtcbiAgICAgICAgX3RoaXMuaW5jcmVtZW50KCk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZLZXkgPT09IGUua2V5Q29kZSkge1xuICAgICAgICBfdGhpcy5kZWNyZW1lbnQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ1cGRhdGVTaXplc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLnN0YXRlLmluaXRpYWxpemVkIHx8ICFfdGhpcy5pdGVtc1JlZiB8fCBfdGhpcy5pdGVtc1JlZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNIb3Jpem9udGFsID0gX3RoaXMucHJvcHMuYXhpcyA9PT0gJ2hvcml6b250YWwnO1xuICAgICAgdmFyIGZpcnN0SXRlbSA9IF90aGlzLml0ZW1zUmVmWzBdO1xuXG4gICAgICBpZiAoIWZpcnN0SXRlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtU2l6ZSA9IGlzSG9yaXpvbnRhbCA/IGZpcnN0SXRlbS5jbGllbnRXaWR0aCA6IGZpcnN0SXRlbS5jbGllbnRIZWlnaHQ7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXRlbVNpemU6IGl0ZW1TaXplXG4gICAgICB9KTtcblxuICAgICAgaWYgKF90aGlzLnRodW1ic1JlZikge1xuICAgICAgICBfdGhpcy50aHVtYnNSZWYudXBkYXRlU2l6ZXMoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzZXRNb3VudFN0YXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaGFzTW91bnQ6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy51cGRhdGVTaXplcygpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhhbmRsZUNsaWNrSXRlbVwiLCBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgIGlmIChfcmVhY3QuQ2hpbGRyZW4uY291bnQoX3RoaXMucHJvcHMuY2hpbGRyZW4pID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLnN0YXRlLmNhbmNlbENsaWNrKSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjYW5jZWxDbGljazogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5wcm9wcy5vbkNsaWNrSXRlbShpbmRleCwgaXRlbSk7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gX3RoaXMuc3RhdGUuc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBzZWxlY3RlZEl0ZW06IGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhhbmRsZU9uQ2hhbmdlXCIsIGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xuICAgICAgaWYgKF9yZWFjdC5DaGlsZHJlbi5jb3VudChfdGhpcy5wcm9wcy5jaGlsZHJlbikgPD0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnByb3BzLm9uQ2hhbmdlKGluZGV4LCBpdGVtKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJoYW5kbGVDbGlja1RodW1iXCIsIGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xuICAgICAgX3RoaXMucHJvcHMub25DbGlja1RodW1iKGluZGV4LCBpdGVtKTtcblxuICAgICAgX3RoaXMubW92ZVRvKGluZGV4KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblN3aXBlU3RhcnRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHN3aXBpbmc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5wcm9wcy5vblN3aXBlU3RhcnQoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uU3dpcGVFbmRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHN3aXBpbmc6IGZhbHNlLFxuICAgICAgICBjYW5jZWxDbGljazogZmFsc2UsXG4gICAgICAgIHN3aXBlTW92ZW1lbnRTdGFydGVkOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLnByb3BzLm9uU3dpcGVFbmQoZXZlbnQpO1xuXG4gICAgICBfdGhpcy5jbGVhckF1dG9QbGF5KCk7XG5cbiAgICAgIGlmIChfdGhpcy5zdGF0ZS5hdXRvUGxheSkge1xuICAgICAgICBfdGhpcy5hdXRvUGxheSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uU3dpcGVNb3ZlXCIsIGZ1bmN0aW9uIChkZWx0YSwgZXZlbnQpIHtcbiAgICAgIF90aGlzLnByb3BzLm9uU3dpcGVNb3ZlKGV2ZW50KTtcblxuICAgICAgdmFyIGFuaW1hdGlvbkhhbmRsZXJSZXNwb25zZSA9IF90aGlzLnByb3BzLnN3aXBlQW5pbWF0aW9uSGFuZGxlcihkZWx0YSwgX3RoaXMucHJvcHMsIF90aGlzLnN0YXRlLCBfdGhpcy5zZXRTdGF0ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKF9vYmplY3RTcHJlYWQoe30sIGFuaW1hdGlvbkhhbmRsZXJSZXNwb25zZSkpOyAvLyBJZiB3ZSBoYXZlIG5vdCBtb3ZlZCwgd2Ugc2hvdWxkIGhhdmUgYW4gZW1wdHkgb2JqZWN0IHJldHVybmVkXG4gICAgICAvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgc2Nyb2xsaW5nIHdoZW4gbm90IHN3aXBpbmdcblxuXG4gICAgICByZXR1cm4gISFPYmplY3Qua2V5cyhhbmltYXRpb25IYW5kbGVyUmVzcG9uc2UpLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJkZWNyZW1lbnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcblxuICAgICAgX3RoaXMubW92ZVRvKF90aGlzLnN0YXRlLnNlbGVjdGVkSXRlbSAtICh0eXBlb2YgcG9zaXRpb25zID09PSAnbnVtYmVyJyA/IHBvc2l0aW9ucyA6IDEpKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJpbmNyZW1lbnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcblxuICAgICAgX3RoaXMubW92ZVRvKF90aGlzLnN0YXRlLnNlbGVjdGVkSXRlbSArICh0eXBlb2YgcG9zaXRpb25zID09PSAnbnVtYmVyJyA/IHBvc2l0aW9ucyA6IDEpKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJtb3ZlVG9cIiwgZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0UG9zaXRpb24gPSBfcmVhY3QuQ2hpbGRyZW4uY291bnQoX3RoaXMucHJvcHMuY2hpbGRyZW4pIC0gMTtcblxuICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICBwb3NpdGlvbiA9IF90aGlzLnByb3BzLmluZmluaXRlTG9vcCA/IGxhc3RQb3NpdGlvbiA6IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbiA+IGxhc3RQb3NpdGlvbikge1xuICAgICAgICBwb3NpdGlvbiA9IF90aGlzLnByb3BzLmluZmluaXRlTG9vcCA/IDAgOiBsYXN0UG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNlbGVjdEl0ZW0oe1xuICAgICAgICAvLyBpZiBpdCdzIG5vdCBhIHNsaWRlciwgd2UgZG9uJ3QgbmVlZCB0byBzZXQgcG9zaXRpb24gaGVyZVxuICAgICAgICBzZWxlY3RlZEl0ZW06IHBvc2l0aW9uXG4gICAgICB9KTsgLy8gZG9uJ3QgcmVzZXQgYXV0byBwbGF5IHdoZW4gc3RvcCBvbiBob3ZlciBpcyBlbmFibGVkLCBkb2luZyBzbyB3aWxsIHRyaWdnZXIgYSBjYWxsIHRvIGF1dG8gcGxheSBtb3JlIHRoYW4gb25jZVxuICAgICAgLy8gYW5kIHdpbGwgcmVzdWx0IGluIHRoZSBpbnRlcnZhbCBmdW5jdGlvbiBub3QgYmVpbmcgY2xlYXJlZCBjb3JyZWN0bHkuXG5cblxuICAgICAgaWYgKF90aGlzLnN0YXRlLmF1dG9QbGF5ICYmIF90aGlzLnN0YXRlLmlzTW91c2VFbnRlcmVkID09PSBmYWxzZSkge1xuICAgICAgICBfdGhpcy5yZXNldEF1dG9QbGF5KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25DbGlja05leHRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuaW5jcmVtZW50KDEpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uQ2xpY2tQcmV2XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmRlY3JlbWVudCgxKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblN3aXBlRm9yd2FyZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5pbmNyZW1lbnQoMSk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5lbXVsYXRlVG91Y2gpIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGNhbmNlbENsaWNrOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uU3dpcGVCYWNrd2FyZHNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuZGVjcmVtZW50KDEpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMuZW11bGF0ZVRvdWNoKSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjYW5jZWxDbGljazogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjaGFuZ2VJdGVtXCIsIGZ1bmN0aW9uIChuZXdJbmRleCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghKDAsIF91dGlscy5pc0tleWJvYXJkRXZlbnQpKGUpIHx8IGUua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgX3RoaXMubW92ZVRvKG5ld0luZGV4KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzZWxlY3RJdGVtXCIsIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgLy8gTWVyZ2UgaW4gdGhlIG5ldyBzdGF0ZSB3aGlsZSB1cGRhdGluZyB1cGRhdGluZyBwcmV2aW91cyBpdGVtXG4gICAgICBfdGhpcy5zZXRTdGF0ZShfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgcHJldmlvdXNJdGVtOiBfdGhpcy5zdGF0ZS5zZWxlY3RlZEl0ZW1cbiAgICAgIH0sIHN0YXRlKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSdW4gYW5pbWF0aW9uIGhhbmRsZXIgYW5kIHVwZGF0ZSBzdHlsZXMgYmFzZWQgb24gaXRcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoX3RoaXMuYW5pbWF0aW9uSGFuZGxlcihfdGhpcy5wcm9wcywgX3RoaXMuc3RhdGUpKTtcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5oYW5kbGVPbkNoYW5nZShzdGF0ZS5zZWxlY3RlZEl0ZW0sIF9yZWFjdC5DaGlsZHJlbi50b0FycmF5KF90aGlzLnByb3BzLmNoaWxkcmVuKVtzdGF0ZS5zZWxlY3RlZEl0ZW1dKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXRJbml0aWFsSW1hZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGVjdGVkSXRlbSA9IF90aGlzLnByb3BzLnNlbGVjdGVkSXRlbTtcbiAgICAgIHZhciBpdGVtID0gX3RoaXMuaXRlbXNSZWYgJiYgX3RoaXMuaXRlbXNSZWZbc2VsZWN0ZWRJdGVtXTtcbiAgICAgIHZhciBpbWFnZXMgPSBpdGVtICYmIGl0ZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpIHx8IFtdO1xuICAgICAgcmV0dXJuIGltYWdlc1swXTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXRWYXJpYWJsZUl0ZW1IZWlnaHRcIiwgZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICB2YXIgaXRlbSA9IF90aGlzLml0ZW1zUmVmICYmIF90aGlzLml0ZW1zUmVmW3Bvc2l0aW9uXTtcblxuICAgICAgaWYgKF90aGlzLnN0YXRlLmhhc01vdW50ICYmIGl0ZW0gJiYgaXRlbS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHNsaWRlSW1hZ2VzID0gaXRlbS5jaGlsZHJlblswXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJykgfHwgW107XG5cbiAgICAgICAgaWYgKHNsaWRlSW1hZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgaW1hZ2UgPSBzbGlkZUltYWdlc1swXTtcblxuICAgICAgICAgIGlmICghaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBpbWFnZSBpcyBzdGlsbCBsb2FkaW5nLCB0aGUgc2l6ZSB3b24ndCBiZSBhdmFpbGFibGUgc28gd2UgdHJpZ2dlciBhIG5ldyByZW5kZXIgYWZ0ZXIgaXQncyBkb25lXG4gICAgICAgICAgICB2YXIgb25JbWFnZUxvYWQgPSBmdW5jdGlvbiBvbkltYWdlTG9hZCgpIHtcbiAgICAgICAgICAgICAgX3RoaXMuZm9yY2VVcGRhdGUoKTtcblxuICAgICAgICAgICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25JbWFnZUxvYWQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uSW1hZ2VMb2FkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gdHJ5IHRvIGdldCBpbWcgZmlyc3QsIGlmIGltZyBub3QgdGhlcmUgZmluZCBmaXJzdCBkaXNwbGF5IHRhZ1xuXG5cbiAgICAgICAgdmFyIGRpc3BsYXlJdGVtID0gc2xpZGVJbWFnZXNbMF0gfHwgaXRlbS5jaGlsZHJlblswXTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGRpc3BsYXlJdGVtLmNsaWVudEhlaWdodDtcbiAgICAgICAgcmV0dXJuIGhlaWdodCA+IDAgPyBoZWlnaHQgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcblxuICAgIHZhciBpbml0U3RhdGUgPSB7XG4gICAgICBpbml0aWFsaXplZDogZmFsc2UsXG4gICAgICBwcmV2aW91c0l0ZW06IHByb3BzLnNlbGVjdGVkSXRlbSxcbiAgICAgIHNlbGVjdGVkSXRlbTogcHJvcHMuc2VsZWN0ZWRJdGVtLFxuICAgICAgaGFzTW91bnQ6IGZhbHNlLFxuICAgICAgaXNNb3VzZUVudGVyZWQ6IGZhbHNlLFxuICAgICAgYXV0b1BsYXk6IHByb3BzLmF1dG9QbGF5LFxuICAgICAgc3dpcGluZzogZmFsc2UsXG4gICAgICBzd2lwZU1vdmVtZW50U3RhcnRlZDogZmFsc2UsXG4gICAgICBjYW5jZWxDbGljazogZmFsc2UsXG4gICAgICBpdGVtU2l6ZTogMSxcbiAgICAgIGl0ZW1MaXN0U3R5bGU6IHt9LFxuICAgICAgc2xpZGVTdHlsZToge30sXG4gICAgICBzZWxlY3RlZFN0eWxlOiB7fSxcbiAgICAgIHByZXZTdHlsZToge31cbiAgICB9O1xuICAgIF90aGlzLmFuaW1hdGlvbkhhbmRsZXIgPSB0eXBlb2YgcHJvcHMuYW5pbWF0aW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wcy5hbmltYXRpb25IYW5kbGVyIHx8IHByb3BzLmFuaW1hdGlvbkhhbmRsZXIgPT09ICdmYWRlJyAmJiBfYW5pbWF0aW9ucy5mYWRlQW5pbWF0aW9uSGFuZGxlciB8fCBfYW5pbWF0aW9ucy5zbGlkZUFuaW1hdGlvbkhhbmRsZXI7XG4gICAgX3RoaXMuc3RhdGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGluaXRTdGF0ZSksIF90aGlzLmFuaW1hdGlvbkhhbmRsZXIocHJvcHMsIGluaXRTdGF0ZSkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDYXJvdXNlbCwgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAoIXRoaXMucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldHVwQ2Fyb3VzZWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgaWYgKCFwcmV2UHJvcHMuY2hpbGRyZW4gJiYgdGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhdGhpcy5zdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLnNldHVwQ2Fyb3VzZWwoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwcmV2UHJvcHMuYXV0b0ZvY3VzICYmIHRoaXMucHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgIHRoaXMuZm9yY2VGb2N1cygpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldlN0YXRlLnN3aXBpbmcgJiYgIXRoaXMuc3RhdGUuc3dpcGluZykge1xuICAgICAgICAvLyBXZSBzdG9wcGVkIHN3aXBpbmcsIGVuc3VyZSB3ZSBhcmUgaGVhZGluZyB0byB0aGUgbmV3L2N1cnJlbnQgc2xpZGUgYW5kIG5vdCBzdHVja1xuICAgICAgICB0aGlzLnNldFN0YXRlKF9vYmplY3RTcHJlYWQoe30sIHRoaXMucHJvcHMuc3RvcFN3aXBpbmdIYW5kbGVyKHRoaXMucHJvcHMsIHRoaXMuc3RhdGUpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2UHJvcHMuc2VsZWN0ZWRJdGVtICE9PSB0aGlzLnByb3BzLnNlbGVjdGVkSXRlbSB8fCBwcmV2UHJvcHMuY2VudGVyTW9kZSAhPT0gdGhpcy5wcm9wcy5jZW50ZXJNb2RlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgdGhpcy5tb3ZlVG8odGhpcy5wcm9wcy5zZWxlY3RlZEl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldlByb3BzLmF1dG9QbGF5ICE9PSB0aGlzLnByb3BzLmF1dG9QbGF5KSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmF1dG9QbGF5KSB7XG4gICAgICAgICAgdGhpcy5zZXR1cEF1dG9QbGF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95QXV0b1BsYXkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGF1dG9QbGF5OiB0aGlzLnByb3BzLmF1dG9QbGF5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuZGVzdHJveUNhcm91c2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwQ2Fyb3VzZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBDYXJvdXNlbCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmJpbmRFdmVudHMoKTtcblxuICAgICAgaWYgKHRoaXMuc3RhdGUuYXV0b1BsYXkgJiYgX3JlYWN0LkNoaWxkcmVuLmNvdW50KHRoaXMucHJvcHMuY2hpbGRyZW4pID4gMSkge1xuICAgICAgICB0aGlzLnNldHVwQXV0b1BsYXkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgIHRoaXMuZm9yY2VGb2N1cygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaW5pdGlhbGl6ZWQ6IHRydWVcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluaXRpYWxJbWFnZSA9IF90aGlzMi5nZXRJbml0aWFsSW1hZ2UoKTtcblxuICAgICAgICBpZiAoaW5pdGlhbEltYWdlICYmICFpbml0aWFsSW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAvLyBpZiBpdCdzIGEgY2Fyb3VzZWwgb2YgaW1hZ2VzLCB3ZSBzZXQgdGhlIG1vdW50IHN0YXRlIGFmdGVyIHRoZSBmaXJzdCBpbWFnZSBpcyBsb2FkZWRcbiAgICAgICAgICBpbml0aWFsSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIF90aGlzMi5zZXRNb3VudFN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIuc2V0TW91bnRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveUNhcm91c2VsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3lDYXJvdXNlbCgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveUF1dG9QbGF5KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwQXV0b1BsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBBdXRvUGxheSgpIHtcbiAgICAgIHRoaXMuYXV0b1BsYXkoKTtcbiAgICAgIHZhciBjYXJvdXNlbFdyYXBwZXIgPSB0aGlzLmNhcm91c2VsV3JhcHBlclJlZjtcblxuICAgICAgaWYgKHRoaXMucHJvcHMuc3RvcE9uSG92ZXIgJiYgY2Fyb3VzZWxXcmFwcGVyKSB7XG4gICAgICAgIGNhcm91c2VsV3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5zdG9wT25Ib3Zlcik7XG4gICAgICAgIGNhcm91c2VsV3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5zdGFydE9uTGVhdmUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95QXV0b1BsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveUF1dG9QbGF5KCkge1xuICAgICAgdGhpcy5jbGVhckF1dG9QbGF5KCk7XG4gICAgICB2YXIgY2Fyb3VzZWxXcmFwcGVyID0gdGhpcy5jYXJvdXNlbFdyYXBwZXJSZWY7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLnN0b3BPbkhvdmVyICYmIGNhcm91c2VsV3JhcHBlcikge1xuICAgICAgICBjYXJvdXNlbFdyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMuc3RvcE9uSG92ZXIpO1xuICAgICAgICBjYXJvdXNlbFdyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuc3RhcnRPbkxlYXZlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuICAgICAgLy8gYXMgdGhlIHdpZHRocyBhcmUgY2FsY3VsYXRlZCwgd2UgbmVlZCB0byByZXNpemVcbiAgICAgIC8vIHRoZSBjYXJvdXNlbCB3aGVuIHRoZSB3aW5kb3cgaXMgcmVzaXplZFxuICAgICAgKDAsIF93aW5kb3cuZGVmYXVsdCkoKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnVwZGF0ZVNpemVzKTsgLy8gaXNzdWUgIzIgLSBpbWFnZSBsb2FkaW5nIHNtYWxsZXJcblxuICAgICAgKDAsIF93aW5kb3cuZGVmYXVsdCkoKS5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy51cGRhdGVTaXplcyk7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLnVzZUtleWJvYXJkQXJyb3dzKSB7XG4gICAgICAgICgwLCBfZG9jdW1lbnQuZGVmYXVsdCkoKS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5uYXZpZ2F0ZVdpdGhLZXlib2FyZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuYmluZEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRFdmVudHMoKSB7XG4gICAgICAvLyByZW1vdmluZyBsaXN0ZW5lcnNcbiAgICAgICgwLCBfd2luZG93LmRlZmF1bHQpKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy51cGRhdGVTaXplcyk7XG4gICAgICAoMCwgX3dpbmRvdy5kZWZhdWx0KSgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLnVwZGF0ZVNpemVzKTtcbiAgICAgIHZhciBpbml0aWFsSW1hZ2UgPSB0aGlzLmdldEluaXRpYWxJbWFnZSgpO1xuXG4gICAgICBpZiAoaW5pdGlhbEltYWdlKSB7XG4gICAgICAgIGluaXRpYWxJbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5zZXRNb3VudFN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJvcHMudXNlS2V5Ym9hcmRBcnJvd3MpIHtcbiAgICAgICAgKDAsIF9kb2N1bWVudC5kZWZhdWx0KSgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm5hdmlnYXRlV2l0aEtleWJvYXJkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yY2VGb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JjZUZvY3VzKCkge1xuICAgICAgdmFyIF90aGlzJGNhcm91c2VsV3JhcHBlcjtcblxuICAgICAgKF90aGlzJGNhcm91c2VsV3JhcHBlciA9IHRoaXMuY2Fyb3VzZWxXcmFwcGVyUmVmKSA9PT0gbnVsbCB8fCBfdGhpcyRjYXJvdXNlbFdyYXBwZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGNhcm91c2VsV3JhcHBlci5mb2N1cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJJdGVtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJJdGVtcyhpc0Nsb25lKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZWFjdC5DaGlsZHJlbi5tYXAodGhpcy5wcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHZhciBpc1NlbGVjdGVkID0gaW5kZXggPT09IF90aGlzMy5zdGF0ZS5zZWxlY3RlZEl0ZW07XG4gICAgICAgIHZhciBpc1ByZXZpb3VzID0gaW5kZXggPT09IF90aGlzMy5zdGF0ZS5wcmV2aW91c0l0ZW07XG4gICAgICAgIHZhciBzdHlsZSA9IGlzU2VsZWN0ZWQgJiYgX3RoaXMzLnN0YXRlLnNlbGVjdGVkU3R5bGUgfHwgaXNQcmV2aW91cyAmJiBfdGhpczMuc3RhdGUucHJldlN0eWxlIHx8IF90aGlzMy5zdGF0ZS5zbGlkZVN0eWxlIHx8IHt9O1xuXG4gICAgICAgIGlmIChfdGhpczMucHJvcHMuY2VudGVyTW9kZSAmJiBfdGhpczMucHJvcHMuYXhpcyA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgc3R5bGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0eWxlKSwge30sIHtcbiAgICAgICAgICAgIG1pbldpZHRoOiBfdGhpczMucHJvcHMuY2VudGVyU2xpZGVQZXJjZW50YWdlICsgJyUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMzLnN0YXRlLnN3aXBpbmcgJiYgX3RoaXMzLnN0YXRlLnN3aXBlTW92ZW1lbnRTdGFydGVkKSB7XG4gICAgICAgICAgc3R5bGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0eWxlKSwge30sIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNsaWRlUHJvcHMgPSB7XG4gICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYoZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5zZXRJdGVtc1JlZihlLCBpbmRleCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBrZXk6ICdpdGVtS2V5JyArIGluZGV4ICsgKGlzQ2xvbmUgPyAnY2xvbmUnIDogJycpLFxuICAgICAgICAgIGNsYXNzTmFtZTogX2Nzc0NsYXNzZXMuZGVmYXVsdC5JVEVNKHRydWUsIGluZGV4ID09PSBfdGhpczMuc3RhdGUuc2VsZWN0ZWRJdGVtLCBpbmRleCA9PT0gX3RoaXMzLnN0YXRlLnByZXZpb3VzSXRlbSksXG4gICAgICAgICAgb25DbGljazogX3RoaXMzLmhhbmRsZUNsaWNrSXRlbS5iaW5kKF90aGlzMywgaW5kZXgsIGl0ZW0pLFxuICAgICAgICAgIHN0eWxlOiBzdHlsZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCBzbGlkZVByb3BzLCBfdGhpczMucHJvcHMucmVuZGVySXRlbShpdGVtLCB7XG4gICAgICAgICAgaXNTZWxlY3RlZDogaW5kZXggPT09IF90aGlzMy5zdGF0ZS5zZWxlY3RlZEl0ZW0sXG4gICAgICAgICAgaXNQcmV2aW91czogaW5kZXggPT09IF90aGlzMy5zdGF0ZS5wcmV2aW91c0l0ZW1cbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckNvbnRyb2xzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNvbnRyb2xzKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgc2hvd0luZGljYXRvcnMgPSBfdGhpcyRwcm9wcy5zaG93SW5kaWNhdG9ycyxcbiAgICAgICAgICBsYWJlbHMgPSBfdGhpcyRwcm9wcy5sYWJlbHMsXG4gICAgICAgICAgcmVuZGVySW5kaWNhdG9yID0gX3RoaXMkcHJvcHMucmVuZGVySW5kaWNhdG9yLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmICghc2hvd0luZGljYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInVsXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImNvbnRyb2wtZG90c1wiXG4gICAgICB9LCBfcmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlckluZGljYXRvciAmJiByZW5kZXJJbmRpY2F0b3IoX3RoaXM0LmNoYW5nZUl0ZW0oaW5kZXgpLCBpbmRleCA9PT0gX3RoaXM0LnN0YXRlLnNlbGVjdGVkSXRlbSwgaW5kZXgsIGxhYmVscy5pdGVtKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyU3RhdHVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclN0YXR1cygpIHtcbiAgICAgIGlmICghdGhpcy5wcm9wcy5zaG93U3RhdHVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImNhcm91c2VsLXN0YXR1c1wiXG4gICAgICB9LCB0aGlzLnByb3BzLnN0YXR1c0Zvcm1hdHRlcih0aGlzLnN0YXRlLnNlbGVjdGVkSXRlbSArIDEsIF9yZWFjdC5DaGlsZHJlbi5jb3VudCh0aGlzLnByb3BzLmNoaWxkcmVuKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJUaHVtYnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVGh1bWJzKCkge1xuICAgICAgaWYgKCF0aGlzLnByb3BzLnNob3dUaHVtYnMgfHwgIXRoaXMucHJvcHMuY2hpbGRyZW4gfHwgX3JlYWN0LkNoaWxkcmVuLmNvdW50KHRoaXMucHJvcHMuY2hpbGRyZW4pID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1RodW1icy5kZWZhdWx0LCB7XG4gICAgICAgIHJlZjogdGhpcy5zZXRUaHVtYnNSZWYsXG4gICAgICAgIG9uU2VsZWN0SXRlbTogdGhpcy5oYW5kbGVDbGlja1RodW1iLFxuICAgICAgICBzZWxlY3RlZEl0ZW06IHRoaXMuc3RhdGUuc2VsZWN0ZWRJdGVtLFxuICAgICAgICB0cmFuc2l0aW9uVGltZTogdGhpcy5wcm9wcy50cmFuc2l0aW9uVGltZSxcbiAgICAgICAgdGh1bWJXaWR0aDogdGhpcy5wcm9wcy50aHVtYldpZHRoLFxuICAgICAgICBsYWJlbHM6IHRoaXMucHJvcHMubGFiZWxzLFxuICAgICAgICBlbXVsYXRlVG91Y2g6IHRoaXMucHJvcHMuZW11bGF0ZVRvdWNoXG4gICAgICB9LCB0aGlzLnByb3BzLnJlbmRlclRodW1icyh0aGlzLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLnByb3BzLmNoaWxkcmVuIHx8IF9yZWFjdC5DaGlsZHJlbi5jb3VudCh0aGlzLnByb3BzLmNoaWxkcmVuKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzU3dpcGVhYmxlID0gdGhpcy5wcm9wcy5zd2lwZWFibGUgJiYgX3JlYWN0LkNoaWxkcmVuLmNvdW50KHRoaXMucHJvcHMuY2hpbGRyZW4pID4gMTtcbiAgICAgIHZhciBpc0hvcml6b250YWwgPSB0aGlzLnByb3BzLmF4aXMgPT09ICdob3Jpem9udGFsJztcbiAgICAgIHZhciBjYW5TaG93QXJyb3dzID0gdGhpcy5wcm9wcy5zaG93QXJyb3dzICYmIF9yZWFjdC5DaGlsZHJlbi5jb3VudCh0aGlzLnByb3BzLmNoaWxkcmVuKSA+IDE7IC8vIHNob3cgbGVmdCBhcnJvdz9cblxuICAgICAgdmFyIGhhc1ByZXYgPSBjYW5TaG93QXJyb3dzICYmICh0aGlzLnN0YXRlLnNlbGVjdGVkSXRlbSA+IDAgfHwgdGhpcy5wcm9wcy5pbmZpbml0ZUxvb3ApIHx8IGZhbHNlOyAvLyBzaG93IHJpZ2h0IGFycm93XG5cbiAgICAgIHZhciBoYXNOZXh0ID0gY2FuU2hvd0Fycm93cyAmJiAodGhpcy5zdGF0ZS5zZWxlY3RlZEl0ZW0gPCBfcmVhY3QuQ2hpbGRyZW4uY291bnQodGhpcy5wcm9wcy5jaGlsZHJlbikgLSAxIHx8IHRoaXMucHJvcHMuaW5maW5pdGVMb29wKSB8fCBmYWxzZTtcbiAgICAgIHZhciBpdGVtc0Nsb25lID0gdGhpcy5yZW5kZXJJdGVtcyh0cnVlKTtcbiAgICAgIHZhciBmaXJzdENsb25lID0gaXRlbXNDbG9uZS5zaGlmdCgpO1xuICAgICAgdmFyIGxhc3RDbG9uZSA9IGl0ZW1zQ2xvbmUucG9wKCk7XG4gICAgICB2YXIgc3dpcGVyUHJvcHMgPSB7XG4gICAgICAgIGNsYXNzTmFtZTogX2Nzc0NsYXNzZXMuZGVmYXVsdC5TTElERVIodHJ1ZSwgdGhpcy5zdGF0ZS5zd2lwaW5nKSxcbiAgICAgICAgb25Td2lwZU1vdmU6IHRoaXMub25Td2lwZU1vdmUsXG4gICAgICAgIG9uU3dpcGVTdGFydDogdGhpcy5vblN3aXBlU3RhcnQsXG4gICAgICAgIG9uU3dpcGVFbmQ6IHRoaXMub25Td2lwZUVuZCxcbiAgICAgICAgc3R5bGU6IHRoaXMuc3RhdGUuaXRlbUxpc3RTdHlsZSxcbiAgICAgICAgdG9sZXJhbmNlOiB0aGlzLnByb3BzLnN3aXBlU2Nyb2xsVG9sZXJhbmNlXG4gICAgICB9O1xuICAgICAgdmFyIGNvbnRhaW5lclN0eWxlcyA9IHt9O1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHN3aXBlclByb3BzLm9uU3dpcGVMZWZ0ID0gdGhpcy5vblN3aXBlRm9yd2FyZDtcbiAgICAgICAgc3dpcGVyUHJvcHMub25Td2lwZVJpZ2h0ID0gdGhpcy5vblN3aXBlQmFja3dhcmRzO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmR5bmFtaWNIZWlnaHQpIHtcbiAgICAgICAgICB2YXIgaXRlbUhlaWdodCA9IHRoaXMuZ2V0VmFyaWFibGVJdGVtSGVpZ2h0KHRoaXMuc3RhdGUuc2VsZWN0ZWRJdGVtKTsgLy8gc3dpcGVyUHJvcHMuc3R5bGUuaGVpZ2h0ID0gaXRlbUhlaWdodCB8fCAnYXV0byc7XG5cbiAgICAgICAgICBjb250YWluZXJTdHlsZXMuaGVpZ2h0ID0gaXRlbUhlaWdodCB8fCAnYXV0byc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlclByb3BzLm9uU3dpcGVVcCA9IHRoaXMucHJvcHMudmVydGljYWxTd2lwZSA9PT0gJ25hdHVyYWwnID8gdGhpcy5vblN3aXBlQmFja3dhcmRzIDogdGhpcy5vblN3aXBlRm9yd2FyZDtcbiAgICAgICAgc3dpcGVyUHJvcHMub25Td2lwZURvd24gPSB0aGlzLnByb3BzLnZlcnRpY2FsU3dpcGUgPT09ICduYXR1cmFsJyA/IHRoaXMub25Td2lwZUZvcndhcmQgOiB0aGlzLm9uU3dpcGVCYWNrd2FyZHM7XG4gICAgICAgIHN3aXBlclByb3BzLnN0eWxlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzd2lwZXJQcm9wcy5zdHlsZSksIHt9LCB7XG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLnN0YXRlLml0ZW1TaXplXG4gICAgICAgIH0pO1xuICAgICAgICBjb250YWluZXJTdHlsZXMuaGVpZ2h0ID0gdGhpcy5zdGF0ZS5pdGVtU2l6ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMucHJvcHMuYXJpYUxhYmVsLFxuICAgICAgICBjbGFzc05hbWU6IF9jc3NDbGFzc2VzLmRlZmF1bHQuUk9PVCh0aGlzLnByb3BzLmNsYXNzTmFtZSksXG4gICAgICAgIHJlZjogdGhpcy5zZXRDYXJvdXNlbFdyYXBwZXJSZWYsXG4gICAgICAgIHRhYkluZGV4OiB0aGlzLnByb3BzLnVzZUtleWJvYXJkQXJyb3dzID8gMCA6IHVuZGVmaW5lZFxuICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IF9jc3NDbGFzc2VzLmRlZmF1bHQuQ0FST1VTRUwodHJ1ZSksXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgd2lkdGg6IHRoaXMucHJvcHMud2lkdGhcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5yZW5kZXJDb250cm9scygpLCB0aGlzLnByb3BzLnJlbmRlckFycm93UHJldih0aGlzLm9uQ2xpY2tQcmV2LCBoYXNQcmV2LCB0aGlzLnByb3BzLmxhYmVscy5sZWZ0QXJyb3cpLCAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogX2Nzc0NsYXNzZXMuZGVmYXVsdC5XUkFQUEVSKHRydWUsIHRoaXMucHJvcHMuYXhpcyksXG4gICAgICAgIHN0eWxlOiBjb250YWluZXJTdHlsZXNcbiAgICAgIH0sIGlzU3dpcGVhYmxlID8gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0RWFzeVN3aXBlLmRlZmF1bHQsIF9leHRlbmRzKHtcbiAgICAgICAgdGFnTmFtZTogXCJ1bFwiLFxuICAgICAgICBpbm5lclJlZjogdGhpcy5zZXRMaXN0UmVmXG4gICAgICB9LCBzd2lwZXJQcm9wcywge1xuICAgICAgICBhbGxvd01vdXNlRXZlbnRzOiB0aGlzLnByb3BzLmVtdWxhdGVUb3VjaFxuICAgICAgfSksIHRoaXMucHJvcHMuaW5maW5pdGVMb29wICYmIGxhc3RDbG9uZSwgdGhpcy5yZW5kZXJJdGVtcygpLCB0aGlzLnByb3BzLmluZmluaXRlTG9vcCAmJiBmaXJzdENsb25lKSA6IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwidWxcIiwge1xuICAgICAgICBjbGFzc05hbWU6IF9jc3NDbGFzc2VzLmRlZmF1bHQuU0xJREVSKHRydWUsIHRoaXMuc3RhdGUuc3dpcGluZyksXG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1LnNldExpc3RSZWYobm9kZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB0aGlzLnN0YXRlLml0ZW1MaXN0U3R5bGUgfHwge31cbiAgICAgIH0sIHRoaXMucHJvcHMuaW5maW5pdGVMb29wICYmIGxhc3RDbG9uZSwgdGhpcy5yZW5kZXJJdGVtcygpLCB0aGlzLnByb3BzLmluZmluaXRlTG9vcCAmJiBmaXJzdENsb25lKSksIHRoaXMucHJvcHMucmVuZGVyQXJyb3dOZXh0KHRoaXMub25DbGlja05leHQsIGhhc05leHQsIHRoaXMucHJvcHMubGFiZWxzLnJpZ2h0QXJyb3cpLCB0aGlzLnJlbmRlclN0YXR1cygpKSwgdGhpcy5yZW5kZXJUaHVtYnMoKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhcm91c2VsO1xufShfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYXJvdXNlbDtcblxuX2RlZmluZVByb3BlcnR5KENhcm91c2VsLCBcImRpc3BsYXlOYW1lXCIsICdDYXJvdXNlbCcpO1xuXG5fZGVmaW5lUHJvcGVydHkoQ2Fyb3VzZWwsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgYXJpYUxhYmVsOiB1bmRlZmluZWQsXG4gIGF4aXM6ICdob3Jpem9udGFsJyxcbiAgY2VudGVyU2xpZGVQZXJjZW50YWdlOiA4MCxcbiAgaW50ZXJ2YWw6IDMwMDAsXG4gIGxhYmVsczoge1xuICAgIGxlZnRBcnJvdzogJ3ByZXZpb3VzIHNsaWRlIC8gaXRlbScsXG4gICAgcmlnaHRBcnJvdzogJ25leHQgc2xpZGUgLyBpdGVtJyxcbiAgICBpdGVtOiAnc2xpZGUgaXRlbSdcbiAgfSxcbiAgb25DbGlja0l0ZW06IF91dGlscy5ub29wLFxuICBvbkNsaWNrVGh1bWI6IF91dGlscy5ub29wLFxuICBvbkNoYW5nZTogX3V0aWxzLm5vb3AsXG4gIG9uU3dpcGVTdGFydDogZnVuY3Rpb24gb25Td2lwZVN0YXJ0KCkge30sXG4gIG9uU3dpcGVFbmQ6IGZ1bmN0aW9uIG9uU3dpcGVFbmQoKSB7fSxcbiAgb25Td2lwZU1vdmU6IGZ1bmN0aW9uIG9uU3dpcGVNb3ZlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcHJldmVudE1vdmVtZW50VW50aWxTd2lwZVNjcm9sbFRvbGVyYW5jZTogZmFsc2UsXG4gIHJlbmRlckFycm93UHJldjogZnVuY3Rpb24gcmVuZGVyQXJyb3dQcmV2KG9uQ2xpY2tIYW5kbGVyLCBoYXNQcmV2LCBsYWJlbCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgXCJhcmlhLWxhYmVsXCI6IGxhYmVsLFxuICAgICAgY2xhc3NOYW1lOiBfY3NzQ2xhc3Nlcy5kZWZhdWx0LkFSUk9XX1BSRVYoIWhhc1ByZXYpLFxuICAgICAgb25DbGljazogb25DbGlja0hhbmRsZXJcbiAgICB9KTtcbiAgfSxcbiAgcmVuZGVyQXJyb3dOZXh0OiBmdW5jdGlvbiByZW5kZXJBcnJvd05leHQob25DbGlja0hhbmRsZXIsIGhhc05leHQsIGxhYmVsKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICBcImFyaWEtbGFiZWxcIjogbGFiZWwsXG4gICAgICBjbGFzc05hbWU6IF9jc3NDbGFzc2VzLmRlZmF1bHQuQVJST1dfTkVYVCghaGFzTmV4dCksXG4gICAgICBvbkNsaWNrOiBvbkNsaWNrSGFuZGxlclxuICAgIH0pO1xuICB9LFxuICByZW5kZXJJbmRpY2F0b3I6IGZ1bmN0aW9uIHJlbmRlckluZGljYXRvcihvbkNsaWNrSGFuZGxlciwgaXNTZWxlY3RlZCwgaW5kZXgsIGxhYmVsKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibGlcIiwge1xuICAgICAgY2xhc3NOYW1lOiBfY3NzQ2xhc3Nlcy5kZWZhdWx0LkRPVChpc1NlbGVjdGVkKSxcbiAgICAgIG9uQ2xpY2s6IG9uQ2xpY2tIYW5kbGVyLFxuICAgICAgb25LZXlEb3duOiBvbkNsaWNrSGFuZGxlcixcbiAgICAgIHZhbHVlOiBpbmRleCxcbiAgICAgIGtleTogaW5kZXgsXG4gICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICBcImFyaWEtbGFiZWxcIjogXCJcIi5jb25jYXQobGFiZWwsIFwiIFwiKS5jb25jYXQoaW5kZXggKyAxKVxuICAgIH0pO1xuICB9LFxuICByZW5kZXJJdGVtOiBmdW5jdGlvbiByZW5kZXJJdGVtKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfSxcbiAgcmVuZGVyVGh1bWJzOiBmdW5jdGlvbiByZW5kZXJUaHVtYnMoY2hpbGRyZW4pIHtcbiAgICB2YXIgaW1hZ2VzID0gX3JlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBpbWcgPSBpdGVtOyAvLyBpZiB0aGUgaXRlbSBpcyBub3QgYW4gaW1hZ2UsIHRyeSB0byBmaW5kIHRoZSBmaXJzdCBpbWFnZSBpbiB0aGUgaXRlbSdzIGNoaWxkcmVuLlxuXG4gICAgICBpZiAoaXRlbS50eXBlICE9PSAnaW1nJykge1xuICAgICAgICBpbWcgPSBfcmVhY3QuQ2hpbGRyZW4udG9BcnJheShpdGVtLnByb3BzLmNoaWxkcmVuKS5maW5kKGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbi50eXBlID09PSAnaW1nJztcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW1nKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbWc7XG4gICAgfSk7XG5cbiAgICBpZiAoaW1hZ2VzLmZpbHRlcihmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9KS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk5vIGltYWdlcyBmb3VuZCEgQ2FuJ3QgYnVpbGQgdGhlIHRodW1iIGxpc3Qgd2l0aG91dCBpbWFnZXMuIElmIHlvdSBkb24ndCBuZWVkIHRodW1icywgc2V0IHNob3dUaHVtYnM9e2ZhbHNlfSBpbiB0aGUgQ2Fyb3VzZWwuIE5vdGUgdGhhdCBpdCdzIG5vdCBwb3NzaWJsZSB0byBnZXQgaW1hZ2VzIHJlbmRlcmVkIGluc2lkZSBjdXN0b20gY29tcG9uZW50cy4gTW9yZSBpbmZvIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9sZWFuZHJvd2QvcmVhY3QtcmVzcG9uc2l2ZS1jYXJvdXNlbC9ibG9iL21hc3Rlci9UUk9VQkxFU0hPT1RJTkcubWRcIik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlcztcbiAgfSxcbiAgc3RhdHVzRm9ybWF0dGVyOiBfdXRpbHMuZGVmYXVsdFN0YXR1c0Zvcm1hdHRlcixcbiAgc2VsZWN0ZWRJdGVtOiAwLFxuICBzaG93QXJyb3dzOiB0cnVlLFxuICBzaG93SW5kaWNhdG9yczogdHJ1ZSxcbiAgc2hvd1N0YXR1czogdHJ1ZSxcbiAgc2hvd1RodW1iczogdHJ1ZSxcbiAgc3RvcE9uSG92ZXI6IHRydWUsXG4gIHN3aXBlU2Nyb2xsVG9sZXJhbmNlOiA1LFxuICBzd2lwZWFibGU6IHRydWUsXG4gIHRyYW5zaXRpb25UaW1lOiAzNTAsXG4gIHZlcnRpY2FsU3dpcGU6ICdzdGFuZGFyZCcsXG4gIHdpZHRoOiAnMTAwJScsXG4gIGFuaW1hdGlvbkhhbmRsZXI6ICdzbGlkZScsXG4gIHN3aXBlQW5pbWF0aW9uSGFuZGxlcjogX2FuaW1hdGlvbnMuc2xpZGVTd2lwZUFuaW1hdGlvbkhhbmRsZXIsXG4gIHN0b3BTd2lwaW5nSGFuZGxlcjogX2FuaW1hdGlvbnMuc2xpZGVTdG9wU3dpcGluZ0hhbmRsZXJcbn0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-responsive-carousel/lib/js/components/Carousel/index.js\n");

/***/ }),

/***/ "./node_modules/react-responsive-carousel/lib/js/components/Carousel/types.js":
/*!************************************************************************************!*\
  !*** ./node_modules/react-responsive-carousel/lib/js/components/Carousel/types.js ***!
  \************************************************************************************/
/***/ (function() {

"use strict";


/***/ }),

/***/ "./node_modules/react-responsive-carousel/lib/js/components/Carousel/utils.js":
/*!************************************************************************************!*\
  !*** ./node_modules/react-responsive-carousel/lib/js/components/Carousel/utils.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.setPosition = exports.getPosition = exports.isKeyboardEvent = exports.defaultStatusFormatter = exports.noop = void 0;\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _CSSTranslate = _interopRequireDefault(__webpack_require__(/*! ../../CSSTranslate */ \"./node_modules/react-responsive-carousel/lib/js/CSSTranslate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar noop = function noop() {};\n\nexports.noop = noop;\n\nvar defaultStatusFormatter = function defaultStatusFormatter(current, total) {\n  return \"\".concat(current, \" of \").concat(total);\n};\n\nexports.defaultStatusFormatter = defaultStatusFormatter;\n\nvar isKeyboardEvent = function isKeyboardEvent(e) {\n  return e ? e.hasOwnProperty('key') : false;\n};\n/**\n * Gets the list 'position' relative to a current index\n * @param index\n */\n\n\nexports.isKeyboardEvent = isKeyboardEvent;\n\nvar getPosition = function getPosition(index, props) {\n  if (props.infiniteLoop) {\n    // index has to be added by 1 because of the first cloned slide\n    ++index;\n  }\n\n  if (index === 0) {\n    return 0;\n  }\n\n  var childrenLength = _react.Children.count(props.children);\n\n  if (props.centerMode && props.axis === 'horizontal') {\n    var currentPosition = -index * props.centerSlidePercentage;\n    var lastPosition = childrenLength - 1;\n\n    if (index && (index !== lastPosition || props.infiniteLoop)) {\n      currentPosition += (100 - props.centerSlidePercentage) / 2;\n    } else if (index === lastPosition) {\n      currentPosition += 100 - props.centerSlidePercentage;\n    }\n\n    return currentPosition;\n  }\n\n  return -index * 100;\n};\n/**\n * Sets the 'position' transform for sliding animations\n * @param position\n * @param forceReflow\n */\n\n\nexports.getPosition = getPosition;\n\nvar setPosition = function setPosition(position, axis) {\n  var style = {};\n  ['WebkitTransform', 'MozTransform', 'MsTransform', 'OTransform', 'transform', 'msTransform'].forEach(function (prop) {\n    // @ts-ignore\n    style[prop] = (0, _CSSTranslate.default)(position, '%', axis);\n  });\n  return style;\n};\n\nexports.setPosition = setPosition;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2pzL2NvbXBvbmVudHMvQ2Fyb3VzZWwvdXRpbHMuanM/MmZmNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyx1QkFBdUIsR0FBRyw4QkFBOEIsR0FBRyxZQUFZOztBQUVuSCxhQUFhLG1CQUFPLENBQUMsNENBQU87O0FBRTVCLDJDQUEyQyxtQkFBTyxDQUFDLDJGQUFvQjs7QUFFdkUsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGOztBQUVBLFlBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxtQkFBbUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS1jYXJvdXNlbC9saWIvanMvY29tcG9uZW50cy9DYXJvdXNlbC91dGlscy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zZXRQb3NpdGlvbiA9IGV4cG9ydHMuZ2V0UG9zaXRpb24gPSBleHBvcnRzLmlzS2V5Ym9hcmRFdmVudCA9IGV4cG9ydHMuZGVmYXVsdFN0YXR1c0Zvcm1hdHRlciA9IGV4cG9ydHMubm9vcCA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxudmFyIF9DU1NUcmFuc2xhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9DU1NUcmFuc2xhdGVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuZXhwb3J0cy5ub29wID0gbm9vcDtcblxudmFyIGRlZmF1bHRTdGF0dXNGb3JtYXR0ZXIgPSBmdW5jdGlvbiBkZWZhdWx0U3RhdHVzRm9ybWF0dGVyKGN1cnJlbnQsIHRvdGFsKSB7XG4gIHJldHVybiBcIlwiLmNvbmNhdChjdXJyZW50LCBcIiBvZiBcIikuY29uY2F0KHRvdGFsKTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdFN0YXR1c0Zvcm1hdHRlciA9IGRlZmF1bHRTdGF0dXNGb3JtYXR0ZXI7XG5cbnZhciBpc0tleWJvYXJkRXZlbnQgPSBmdW5jdGlvbiBpc0tleWJvYXJkRXZlbnQoZSkge1xuICByZXR1cm4gZSA/IGUuaGFzT3duUHJvcGVydHkoJ2tleScpIDogZmFsc2U7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBsaXN0ICdwb3NpdGlvbicgcmVsYXRpdmUgdG8gYSBjdXJyZW50IGluZGV4XG4gKiBAcGFyYW0gaW5kZXhcbiAqL1xuXG5cbmV4cG9ydHMuaXNLZXlib2FyZEV2ZW50ID0gaXNLZXlib2FyZEV2ZW50O1xuXG52YXIgZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbihpbmRleCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzLmluZmluaXRlTG9vcCkge1xuICAgIC8vIGluZGV4IGhhcyB0byBiZSBhZGRlZCBieSAxIGJlY2F1c2Ugb2YgdGhlIGZpcnN0IGNsb25lZCBzbGlkZVxuICAgICsraW5kZXg7XG4gIH1cblxuICBpZiAoaW5kZXggPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IF9yZWFjdC5DaGlsZHJlbi5jb3VudChwcm9wcy5jaGlsZHJlbik7XG5cbiAgaWYgKHByb3BzLmNlbnRlck1vZGUgJiYgcHJvcHMuYXhpcyA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IC1pbmRleCAqIHByb3BzLmNlbnRlclNsaWRlUGVyY2VudGFnZTtcbiAgICB2YXIgbGFzdFBvc2l0aW9uID0gY2hpbGRyZW5MZW5ndGggLSAxO1xuXG4gICAgaWYgKGluZGV4ICYmIChpbmRleCAhPT0gbGFzdFBvc2l0aW9uIHx8IHByb3BzLmluZmluaXRlTG9vcCkpIHtcbiAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSAoMTAwIC0gcHJvcHMuY2VudGVyU2xpZGVQZXJjZW50YWdlKSAvIDI7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gbGFzdFBvc2l0aW9uKSB7XG4gICAgICBjdXJyZW50UG9zaXRpb24gKz0gMTAwIC0gcHJvcHMuY2VudGVyU2xpZGVQZXJjZW50YWdlO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50UG9zaXRpb247XG4gIH1cblxuICByZXR1cm4gLWluZGV4ICogMTAwO1xufTtcbi8qKlxuICogU2V0cyB0aGUgJ3Bvc2l0aW9uJyB0cmFuc2Zvcm0gZm9yIHNsaWRpbmcgYW5pbWF0aW9uc1xuICogQHBhcmFtIHBvc2l0aW9uXG4gKiBAcGFyYW0gZm9yY2VSZWZsb3dcbiAqL1xuXG5cbmV4cG9ydHMuZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbjtcblxudmFyIHNldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9zaXRpb24ocG9zaXRpb24sIGF4aXMpIHtcbiAgdmFyIHN0eWxlID0ge307XG4gIFsnV2Via2l0VHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdNc1RyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ3RyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc3R5bGVbcHJvcF0gPSAoMCwgX0NTU1RyYW5zbGF0ZS5kZWZhdWx0KShwb3NpdGlvbiwgJyUnLCBheGlzKTtcbiAgfSk7XG4gIHJldHVybiBzdHlsZTtcbn07XG5cbmV4cG9ydHMuc2V0UG9zaXRpb24gPSBzZXRQb3NpdGlvbjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-responsive-carousel/lib/js/components/Carousel/utils.js\n");

/***/ }),

/***/ "./node_modules/react-responsive-carousel/lib/js/components/Thumbs.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-responsive-carousel/lib/js/components/Thumbs.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _cssClasses = _interopRequireDefault(__webpack_require__(/*! ../cssClasses */ \"./node_modules/react-responsive-carousel/lib/js/cssClasses.js\"));\n\nvar _dimensions = __webpack_require__(/*! ../dimensions */ \"./node_modules/react-responsive-carousel/lib/js/dimensions.js\");\n\nvar _CSSTranslate = _interopRequireDefault(__webpack_require__(/*! ../CSSTranslate */ \"./node_modules/react-responsive-carousel/lib/js/CSSTranslate.js\"));\n\nvar _reactEasySwipe = _interopRequireDefault(__webpack_require__(/*! react-easy-swipe */ \"./node_modules/react-easy-swipe/lib/index.js\"));\n\nvar _window = _interopRequireDefault(__webpack_require__(/*! ../shims/window */ \"./node_modules/react-responsive-carousel/lib/js/shims/window.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar isKeyboardEvent = function isKeyboardEvent(e) {\n  return e.hasOwnProperty('key');\n};\n\nvar Thumbs = /*#__PURE__*/function (_Component) {\n  _inherits(Thumbs, _Component);\n\n  var _super = _createSuper(Thumbs);\n\n  function Thumbs(_props) {\n    var _this;\n\n    _classCallCheck(this, Thumbs);\n\n    _this = _super.call(this, _props);\n\n    _defineProperty(_assertThisInitialized(_this), \"itemsWrapperRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"itemsListRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"thumbsRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"setItemsWrapperRef\", function (node) {\n      _this.itemsWrapperRef = node;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setItemsListRef\", function (node) {\n      _this.itemsListRef = node;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setThumbsRef\", function (node, index) {\n      if (!_this.thumbsRef) {\n        _this.thumbsRef = [];\n      }\n\n      _this.thumbsRef[index] = node;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"updateSizes\", function () {\n      if (!_this.props.children || !_this.itemsWrapperRef || !_this.thumbsRef) {\n        return;\n      }\n\n      var total = _react.Children.count(_this.props.children);\n\n      var wrapperSize = _this.itemsWrapperRef.clientWidth;\n      var itemSize = _this.props.thumbWidth ? _this.props.thumbWidth : (0, _dimensions.outerWidth)(_this.thumbsRef[0]);\n      var visibleItems = Math.floor(wrapperSize / itemSize);\n      var showArrows = visibleItems < total;\n      var lastPosition = showArrows ? total - visibleItems : 0;\n\n      _this.setState(function (_state, props) {\n        return {\n          itemSize: itemSize,\n          visibleItems: visibleItems,\n          firstItem: showArrows ? _this.getFirstItem(props.selectedItem) : 0,\n          lastPosition: lastPosition,\n          showArrows: showArrows\n        };\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleClickItem\", function (index, item, e) {\n      if (!isKeyboardEvent(e) || e.key === 'Enter') {\n        var handler = _this.props.onSelectItem;\n\n        if (typeof handler === 'function') {\n          handler(index, item);\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onSwipeStart\", function () {\n      _this.setState({\n        swiping: true\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onSwipeEnd\", function () {\n      _this.setState({\n        swiping: false\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onSwipeMove\", function (delta) {\n      var deltaX = delta.x;\n\n      if (!_this.state.itemSize || !_this.itemsWrapperRef || !_this.state.visibleItems) {\n        return false;\n      }\n\n      var leftBoundary = 0;\n\n      var childrenLength = _react.Children.count(_this.props.children);\n\n      var currentPosition = -(_this.state.firstItem * 100) / _this.state.visibleItems;\n      var lastLeftItem = Math.max(childrenLength - _this.state.visibleItems, 0);\n      var lastLeftBoundary = -lastLeftItem * 100 / _this.state.visibleItems; // prevent user from swiping left out of boundaries\n\n      if (currentPosition === leftBoundary && deltaX > 0) {\n        deltaX = 0;\n      } // prevent user from swiping right out of boundaries\n\n\n      if (currentPosition === lastLeftBoundary && deltaX < 0) {\n        deltaX = 0;\n      }\n\n      var wrapperSize = _this.itemsWrapperRef.clientWidth;\n      var position = currentPosition + 100 / (wrapperSize / deltaX); // if 3d isn't available we will use left to move\n\n      if (_this.itemsListRef) {\n        ['WebkitTransform', 'MozTransform', 'MsTransform', 'OTransform', 'transform', 'msTransform'].forEach(function (prop) {\n          _this.itemsListRef.style[prop] = (0, _CSSTranslate.default)(position, '%', _this.props.axis);\n        });\n      }\n\n      return true;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"slideRight\", function (positions) {\n      _this.moveTo(_this.state.firstItem - (typeof positions === 'number' ? positions : 1));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"slideLeft\", function (positions) {\n      _this.moveTo(_this.state.firstItem + (typeof positions === 'number' ? positions : 1));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"moveTo\", function (position) {\n      // position can't be lower than 0\n      position = position < 0 ? 0 : position; // position can't be higher than last postion\n\n      position = position >= _this.state.lastPosition ? _this.state.lastPosition : position;\n\n      _this.setState({\n        firstItem: position\n      });\n    });\n\n    _this.state = {\n      selectedItem: _props.selectedItem,\n      swiping: false,\n      showArrows: false,\n      firstItem: 0,\n      visibleItems: 0,\n      lastPosition: 0\n    };\n    return _this;\n  }\n\n  _createClass(Thumbs, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.setupThumbs();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.props.selectedItem !== this.state.selectedItem) {\n        this.setState({\n          selectedItem: this.props.selectedItem,\n          firstItem: this.getFirstItem(this.props.selectedItem)\n        });\n      }\n\n      if (this.props.children === prevProps.children) {\n        return;\n      } // This will capture any size changes for arrow adjustments etc.\n      // usually in the same render cycle so we don't see any flickers\n\n\n      this.updateSizes();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.destroyThumbs();\n    }\n  }, {\n    key: \"setupThumbs\",\n    value: function setupThumbs() {\n      // as the widths are calculated, we need to resize\n      // the carousel when the window is resized\n      (0, _window.default)().addEventListener('resize', this.updateSizes); // issue #2 - image loading smaller\n\n      (0, _window.default)().addEventListener('DOMContentLoaded', this.updateSizes); // when the component is rendered we need to calculate\n      // the container size to adjust the responsive behaviour\n\n      this.updateSizes();\n    }\n  }, {\n    key: \"destroyThumbs\",\n    value: function destroyThumbs() {\n      // removing listeners\n      (0, _window.default)().removeEventListener('resize', this.updateSizes);\n      (0, _window.default)().removeEventListener('DOMContentLoaded', this.updateSizes);\n    }\n  }, {\n    key: \"getFirstItem\",\n    value: function getFirstItem(selectedItem) {\n      var firstItem = selectedItem;\n\n      if (selectedItem >= this.state.lastPosition) {\n        firstItem = this.state.lastPosition;\n      }\n\n      if (selectedItem < this.state.firstItem + this.state.visibleItems) {\n        firstItem = this.state.firstItem;\n      }\n\n      if (selectedItem < this.state.firstItem) {\n        firstItem = selectedItem;\n      }\n\n      return firstItem;\n    }\n  }, {\n    key: \"renderItems\",\n    value: function renderItems() {\n      var _this2 = this;\n\n      return this.props.children.map(function (img, index) {\n        var itemClass = _cssClasses.default.ITEM(false, index === _this2.state.selectedItem);\n\n        var thumbProps = {\n          key: index,\n          ref: function ref(e) {\n            return _this2.setThumbsRef(e, index);\n          },\n          className: itemClass,\n          onClick: _this2.handleClickItem.bind(_this2, index, _this2.props.children[index]),\n          onKeyDown: _this2.handleClickItem.bind(_this2, index, _this2.props.children[index]),\n          'aria-label': \"\".concat(_this2.props.labels.item, \" \").concat(index + 1),\n          style: {\n            width: _this2.props.thumbWidth\n          }\n        };\n        return /*#__PURE__*/_react.default.createElement(\"li\", _extends({}, thumbProps, {\n          role: \"button\",\n          tabIndex: 0\n        }), img);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      if (!this.props.children) {\n        return null;\n      }\n\n      var isSwipeable = _react.Children.count(this.props.children) > 1; // show left arrow?\n\n      var hasPrev = this.state.showArrows && this.state.firstItem > 0; // show right arrow\n\n      var hasNext = this.state.showArrows && this.state.firstItem < this.state.lastPosition; // obj to hold the transformations and styles\n\n      var itemListStyles = {};\n      var currentPosition = -this.state.firstItem * (this.state.itemSize || 0);\n      var transformProp = (0, _CSSTranslate.default)(currentPosition, 'px', this.props.axis);\n      var transitionTime = this.props.transitionTime + 'ms';\n      itemListStyles = {\n        WebkitTransform: transformProp,\n        MozTransform: transformProp,\n        MsTransform: transformProp,\n        OTransform: transformProp,\n        transform: transformProp,\n        msTransform: transformProp,\n        WebkitTransitionDuration: transitionTime,\n        MozTransitionDuration: transitionTime,\n        MsTransitionDuration: transitionTime,\n        OTransitionDuration: transitionTime,\n        transitionDuration: transitionTime,\n        msTransitionDuration: transitionTime\n      };\n      return /*#__PURE__*/_react.default.createElement(\"div\", {\n        className: _cssClasses.default.CAROUSEL(false)\n      }, /*#__PURE__*/_react.default.createElement(\"div\", {\n        className: _cssClasses.default.WRAPPER(false),\n        ref: this.setItemsWrapperRef\n      }, /*#__PURE__*/_react.default.createElement(\"button\", {\n        type: \"button\",\n        className: _cssClasses.default.ARROW_PREV(!hasPrev),\n        onClick: function onClick() {\n          return _this3.slideRight();\n        },\n        \"aria-label\": this.props.labels.leftArrow\n      }), isSwipeable ? /*#__PURE__*/_react.default.createElement(_reactEasySwipe.default, {\n        tagName: \"ul\",\n        className: _cssClasses.default.SLIDER(false, this.state.swiping),\n        onSwipeLeft: this.slideLeft,\n        onSwipeRight: this.slideRight,\n        onSwipeMove: this.onSwipeMove,\n        onSwipeStart: this.onSwipeStart,\n        onSwipeEnd: this.onSwipeEnd,\n        style: itemListStyles,\n        innerRef: this.setItemsListRef,\n        allowMouseEvents: this.props.emulateTouch\n      }, this.renderItems()) : /*#__PURE__*/_react.default.createElement(\"ul\", {\n        className: _cssClasses.default.SLIDER(false, this.state.swiping),\n        ref: function ref(node) {\n          return _this3.setItemsListRef(node);\n        },\n        style: itemListStyles\n      }, this.renderItems()), /*#__PURE__*/_react.default.createElement(\"button\", {\n        type: \"button\",\n        className: _cssClasses.default.ARROW_NEXT(!hasNext),\n        onClick: function onClick() {\n          return _this3.slideLeft();\n        },\n        \"aria-label\": this.props.labels.rightArrow\n      })));\n    }\n  }]);\n\n  return Thumbs;\n}(_react.Component);\n\nexports.default = Thumbs;\n\n_defineProperty(Thumbs, \"displayName\", 'Thumbs');\n\n_defineProperty(Thumbs, \"defaultProps\", {\n  axis: 'horizontal',\n  labels: {\n    leftArrow: 'previous slide / item',\n    rightArrow: 'next slide / item',\n    item: 'slide item'\n  },\n  selectedItem: 0,\n  thumbWidth: 80,\n  transitionTime: 350\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2pzL2NvbXBvbmVudHMvVGh1bWJzLmpzP2M4NGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZUFBZTs7QUFFZixxQ0FBcUMsbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFcEQseUNBQXlDLG1CQUFPLENBQUMsb0ZBQWU7O0FBRWhFLGtCQUFrQixtQkFBTyxDQUFDLG9GQUFlOztBQUV6QywyQ0FBMkMsbUJBQU8sQ0FBQyx3RkFBaUI7O0FBRXBFLDZDQUE2QyxtQkFBTyxDQUFDLHNFQUFrQjs7QUFFdkUscUNBQXFDLG1CQUFPLENBQUMsd0ZBQWlCOztBQUU5RCxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0YscUNBQXFDLGdEQUFnRCwyQkFBMkIsaUVBQWlFLGNBQWMsR0FBRyxjQUFjOztBQUVoTix1Q0FBdUMsNkJBQTZCLFlBQVksRUFBRSw4RUFBOEUsU0FBUyxnQkFBZ0IsRUFBRSx3Q0FBd0MsK0JBQStCLHVCQUF1QixFQUFFLGlCQUFpQixzRkFBc0YsdUJBQXVCLHNEQUFzRCxxRkFBcUYsc0NBQXNDLDBDQUEwQyxFQUFFLE9BQU8sd0JBQXdCLEVBQUUsRUFBRSxFQUFFLHNCQUFzQixhQUFhLHdCQUF3QixFQUFFLGVBQWU7O0FBRXZ1Qix1QkFBdUIsMkJBQTJCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFeFgscUJBQXFCLGdEQUFnRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWUsR0FBRyx3Q0FBd0M7O0FBRTNULGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOLDBDQUEwQywrREFBK0QsMkVBQTJFLEVBQUUseUVBQXlFLGVBQWUsc0RBQXNELEVBQUUsRUFBRSx1REFBdUQ7O0FBRS9YLGdDQUFnQyw0RUFBNEUsaUJBQWlCLFVBQVUsR0FBRyw4QkFBOEI7O0FBRXhLLGdDQUFnQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELHlEQUF5RCxFQUFFLE9BQU8sdUNBQXVDLEVBQUUsaURBQWlELEdBQUc7O0FBRXZhLGlEQUFpRCwwRUFBMEUsYUFBYSxFQUFFLHFDQUFxQzs7QUFFL0ssdUNBQXVDLHVCQUF1Qix1RkFBdUYsRUFBRSxhQUFhOztBQUVwSyxzQ0FBc0Msd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSx3RUFBd0UsR0FBRyxhQUFhLEVBQUUsWUFBWSxjQUFjLEVBQUU7O0FBRWxVLDZCQUE2QixnR0FBZ0csZ0RBQWdELEdBQUcsMkJBQTJCOztBQUUzTSwyQ0FBMkMsa0JBQWtCLGtDQUFrQyxxRUFBcUUsRUFBRSxFQUFFLE9BQU8sa0JBQWtCLEVBQUUsWUFBWTs7QUFFL007QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNEVBQTRFOztBQUU1RTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFOztBQUUxRSxvRkFBb0Y7QUFDcEY7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVFQUF1RTs7QUFFdkUsc0VBQXNFOztBQUV0RSw0RkFBNEY7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCxlQUFlOztBQUVmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2pzL2NvbXBvbmVudHMvVGh1bWJzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX2Nzc0NsYXNzZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9jc3NDbGFzc2VzXCIpKTtcblxudmFyIF9kaW1lbnNpb25zID0gcmVxdWlyZShcIi4uL2RpbWVuc2lvbnNcIik7XG5cbnZhciBfQ1NTVHJhbnNsYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vQ1NTVHJhbnNsYXRlXCIpKTtcblxudmFyIF9yZWFjdEVhc3lTd2lwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LWVhc3ktc3dpcGVcIikpO1xuXG52YXIgX3dpbmRvdyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3NoaW1zL3dpbmRvd1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGlzS2V5Ym9hcmRFdmVudCA9IGZ1bmN0aW9uIGlzS2V5Ym9hcmRFdmVudChlKSB7XG4gIHJldHVybiBlLmhhc093blByb3BlcnR5KCdrZXknKTtcbn07XG5cbnZhciBUaHVtYnMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFRodW1icywgX0NvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUaHVtYnMpO1xuXG4gIGZ1bmN0aW9uIFRodW1icyhfcHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGh1bWJzKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX3Byb3BzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJpdGVtc1dyYXBwZXJSZWZcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJpdGVtc0xpc3RSZWZcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ0aHVtYnNSZWZcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzZXRJdGVtc1dyYXBwZXJSZWZcIiwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIF90aGlzLml0ZW1zV3JhcHBlclJlZiA9IG5vZGU7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2V0SXRlbXNMaXN0UmVmXCIsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBfdGhpcy5pdGVtc0xpc3RSZWYgPSBub2RlO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNldFRodW1ic1JlZlwiLCBmdW5jdGlvbiAobm9kZSwgaW5kZXgpIHtcbiAgICAgIGlmICghX3RoaXMudGh1bWJzUmVmKSB7XG4gICAgICAgIF90aGlzLnRodW1ic1JlZiA9IFtdO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy50aHVtYnNSZWZbaW5kZXhdID0gbm9kZTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ1cGRhdGVTaXplc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLnByb3BzLmNoaWxkcmVuIHx8ICFfdGhpcy5pdGVtc1dyYXBwZXJSZWYgfHwgIV90aGlzLnRodW1ic1JlZikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3RhbCA9IF9yZWFjdC5DaGlsZHJlbi5jb3VudChfdGhpcy5wcm9wcy5jaGlsZHJlbik7XG5cbiAgICAgIHZhciB3cmFwcGVyU2l6ZSA9IF90aGlzLml0ZW1zV3JhcHBlclJlZi5jbGllbnRXaWR0aDtcbiAgICAgIHZhciBpdGVtU2l6ZSA9IF90aGlzLnByb3BzLnRodW1iV2lkdGggPyBfdGhpcy5wcm9wcy50aHVtYldpZHRoIDogKDAsIF9kaW1lbnNpb25zLm91dGVyV2lkdGgpKF90aGlzLnRodW1ic1JlZlswXSk7XG4gICAgICB2YXIgdmlzaWJsZUl0ZW1zID0gTWF0aC5mbG9vcih3cmFwcGVyU2l6ZSAvIGl0ZW1TaXplKTtcbiAgICAgIHZhciBzaG93QXJyb3dzID0gdmlzaWJsZUl0ZW1zIDwgdG90YWw7XG4gICAgICB2YXIgbGFzdFBvc2l0aW9uID0gc2hvd0Fycm93cyA/IHRvdGFsIC0gdmlzaWJsZUl0ZW1zIDogMDtcblxuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKF9zdGF0ZSwgcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpdGVtU2l6ZTogaXRlbVNpemUsXG4gICAgICAgICAgdmlzaWJsZUl0ZW1zOiB2aXNpYmxlSXRlbXMsXG4gICAgICAgICAgZmlyc3RJdGVtOiBzaG93QXJyb3dzID8gX3RoaXMuZ2V0Rmlyc3RJdGVtKHByb3BzLnNlbGVjdGVkSXRlbSkgOiAwLFxuICAgICAgICAgIGxhc3RQb3NpdGlvbjogbGFzdFBvc2l0aW9uLFxuICAgICAgICAgIHNob3dBcnJvd3M6IHNob3dBcnJvd3NcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhhbmRsZUNsaWNrSXRlbVwiLCBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0sIGUpIHtcbiAgICAgIGlmICghaXNLZXlib2FyZEV2ZW50KGUpIHx8IGUua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gX3RoaXMucHJvcHMub25TZWxlY3RJdGVtO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGhhbmRsZXIoaW5kZXgsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25Td2lwZVN0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc3dpcGluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25Td2lwZUVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHN3aXBpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblN3aXBlTW92ZVwiLCBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgIHZhciBkZWx0YVggPSBkZWx0YS54O1xuXG4gICAgICBpZiAoIV90aGlzLnN0YXRlLml0ZW1TaXplIHx8ICFfdGhpcy5pdGVtc1dyYXBwZXJSZWYgfHwgIV90aGlzLnN0YXRlLnZpc2libGVJdGVtcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0Qm91bmRhcnkgPSAwO1xuXG4gICAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSBfcmVhY3QuQ2hpbGRyZW4uY291bnQoX3RoaXMucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gLShfdGhpcy5zdGF0ZS5maXJzdEl0ZW0gKiAxMDApIC8gX3RoaXMuc3RhdGUudmlzaWJsZUl0ZW1zO1xuICAgICAgdmFyIGxhc3RMZWZ0SXRlbSA9IE1hdGgubWF4KGNoaWxkcmVuTGVuZ3RoIC0gX3RoaXMuc3RhdGUudmlzaWJsZUl0ZW1zLCAwKTtcbiAgICAgIHZhciBsYXN0TGVmdEJvdW5kYXJ5ID0gLWxhc3RMZWZ0SXRlbSAqIDEwMCAvIF90aGlzLnN0YXRlLnZpc2libGVJdGVtczsgLy8gcHJldmVudCB1c2VyIGZyb20gc3dpcGluZyBsZWZ0IG91dCBvZiBib3VuZGFyaWVzXG5cbiAgICAgIGlmIChjdXJyZW50UG9zaXRpb24gPT09IGxlZnRCb3VuZGFyeSAmJiBkZWx0YVggPiAwKSB7XG4gICAgICAgIGRlbHRhWCA9IDA7XG4gICAgICB9IC8vIHByZXZlbnQgdXNlciBmcm9tIHN3aXBpbmcgcmlnaHQgb3V0IG9mIGJvdW5kYXJpZXNcblxuXG4gICAgICBpZiAoY3VycmVudFBvc2l0aW9uID09PSBsYXN0TGVmdEJvdW5kYXJ5ICYmIGRlbHRhWCA8IDApIHtcbiAgICAgICAgZGVsdGFYID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHdyYXBwZXJTaXplID0gX3RoaXMuaXRlbXNXcmFwcGVyUmVmLmNsaWVudFdpZHRoO1xuICAgICAgdmFyIHBvc2l0aW9uID0gY3VycmVudFBvc2l0aW9uICsgMTAwIC8gKHdyYXBwZXJTaXplIC8gZGVsdGFYKTsgLy8gaWYgM2QgaXNuJ3QgYXZhaWxhYmxlIHdlIHdpbGwgdXNlIGxlZnQgdG8gbW92ZVxuXG4gICAgICBpZiAoX3RoaXMuaXRlbXNMaXN0UmVmKSB7XG4gICAgICAgIFsnV2Via2l0VHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdNc1RyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ3RyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICBfdGhpcy5pdGVtc0xpc3RSZWYuc3R5bGVbcHJvcF0gPSAoMCwgX0NTU1RyYW5zbGF0ZS5kZWZhdWx0KShwb3NpdGlvbiwgJyUnLCBfdGhpcy5wcm9wcy5heGlzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNsaWRlUmlnaHRcIiwgZnVuY3Rpb24gKHBvc2l0aW9ucykge1xuICAgICAgX3RoaXMubW92ZVRvKF90aGlzLnN0YXRlLmZpcnN0SXRlbSAtICh0eXBlb2YgcG9zaXRpb25zID09PSAnbnVtYmVyJyA/IHBvc2l0aW9ucyA6IDEpKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzbGlkZUxlZnRcIiwgZnVuY3Rpb24gKHBvc2l0aW9ucykge1xuICAgICAgX3RoaXMubW92ZVRvKF90aGlzLnN0YXRlLmZpcnN0SXRlbSArICh0eXBlb2YgcG9zaXRpb25zID09PSAnbnVtYmVyJyA/IHBvc2l0aW9ucyA6IDEpKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJtb3ZlVG9cIiwgZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAvLyBwb3NpdGlvbiBjYW4ndCBiZSBsb3dlciB0aGFuIDBcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPCAwID8gMCA6IHBvc2l0aW9uOyAvLyBwb3NpdGlvbiBjYW4ndCBiZSBoaWdoZXIgdGhhbiBsYXN0IHBvc3Rpb25cblxuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA+PSBfdGhpcy5zdGF0ZS5sYXN0UG9zaXRpb24gPyBfdGhpcy5zdGF0ZS5sYXN0UG9zaXRpb24gOiBwb3NpdGlvbjtcblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBmaXJzdEl0ZW06IHBvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgc2VsZWN0ZWRJdGVtOiBfcHJvcHMuc2VsZWN0ZWRJdGVtLFxuICAgICAgc3dpcGluZzogZmFsc2UsXG4gICAgICBzaG93QXJyb3dzOiBmYWxzZSxcbiAgICAgIGZpcnN0SXRlbTogMCxcbiAgICAgIHZpc2libGVJdGVtczogMCxcbiAgICAgIGxhc3RQb3NpdGlvbjogMFxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRodW1icywgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLnNldHVwVGh1bWJzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5zZWxlY3RlZEl0ZW0gIT09IHRoaXMuc3RhdGUuc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHNlbGVjdGVkSXRlbTogdGhpcy5wcm9wcy5zZWxlY3RlZEl0ZW0sXG4gICAgICAgICAgZmlyc3RJdGVtOiB0aGlzLmdldEZpcnN0SXRlbSh0aGlzLnByb3BzLnNlbGVjdGVkSXRlbSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmNoaWxkcmVuID09PSBwcmV2UHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUaGlzIHdpbGwgY2FwdHVyZSBhbnkgc2l6ZSBjaGFuZ2VzIGZvciBhcnJvdyBhZGp1c3RtZW50cyBldGMuXG4gICAgICAvLyB1c3VhbGx5IGluIHRoZSBzYW1lIHJlbmRlciBjeWNsZSBzbyB3ZSBkb24ndCBzZWUgYW55IGZsaWNrZXJzXG5cblxuICAgICAgdGhpcy51cGRhdGVTaXplcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuZGVzdHJveVRodW1icygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXR1cFRodW1ic1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFRodW1icygpIHtcbiAgICAgIC8vIGFzIHRoZSB3aWR0aHMgYXJlIGNhbGN1bGF0ZWQsIHdlIG5lZWQgdG8gcmVzaXplXG4gICAgICAvLyB0aGUgY2Fyb3VzZWwgd2hlbiB0aGUgd2luZG93IGlzIHJlc2l6ZWRcbiAgICAgICgwLCBfd2luZG93LmRlZmF1bHQpKCkuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy51cGRhdGVTaXplcyk7IC8vIGlzc3VlICMyIC0gaW1hZ2UgbG9hZGluZyBzbWFsbGVyXG5cbiAgICAgICgwLCBfd2luZG93LmRlZmF1bHQpKCkuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMudXBkYXRlU2l6ZXMpOyAvLyB3aGVuIHRoZSBjb21wb25lbnQgaXMgcmVuZGVyZWQgd2UgbmVlZCB0byBjYWxjdWxhdGVcbiAgICAgIC8vIHRoZSBjb250YWluZXIgc2l6ZSB0byBhZGp1c3QgdGhlIHJlc3BvbnNpdmUgYmVoYXZpb3VyXG5cbiAgICAgIHRoaXMudXBkYXRlU2l6ZXMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVRodW1ic1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95VGh1bWJzKCkge1xuICAgICAgLy8gcmVtb3ZpbmcgbGlzdGVuZXJzXG4gICAgICAoMCwgX3dpbmRvdy5kZWZhdWx0KSgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMudXBkYXRlU2l6ZXMpO1xuICAgICAgKDAsIF93aW5kb3cuZGVmYXVsdCkoKS5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy51cGRhdGVTaXplcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZpcnN0SXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaXJzdEl0ZW0oc2VsZWN0ZWRJdGVtKSB7XG4gICAgICB2YXIgZmlyc3RJdGVtID0gc2VsZWN0ZWRJdGVtO1xuXG4gICAgICBpZiAoc2VsZWN0ZWRJdGVtID49IHRoaXMuc3RhdGUubGFzdFBvc2l0aW9uKSB7XG4gICAgICAgIGZpcnN0SXRlbSA9IHRoaXMuc3RhdGUubGFzdFBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ZWRJdGVtIDwgdGhpcy5zdGF0ZS5maXJzdEl0ZW0gKyB0aGlzLnN0YXRlLnZpc2libGVJdGVtcykge1xuICAgICAgICBmaXJzdEl0ZW0gPSB0aGlzLnN0YXRlLmZpcnN0SXRlbTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGVkSXRlbSA8IHRoaXMuc3RhdGUuZmlyc3RJdGVtKSB7XG4gICAgICAgIGZpcnN0SXRlbSA9IHNlbGVjdGVkSXRlbTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpcnN0SXRlbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVySXRlbXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVySXRlbXMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChpbWcsIGluZGV4KSB7XG4gICAgICAgIHZhciBpdGVtQ2xhc3MgPSBfY3NzQ2xhc3Nlcy5kZWZhdWx0LklURU0oZmFsc2UsIGluZGV4ID09PSBfdGhpczIuc3RhdGUuc2VsZWN0ZWRJdGVtKTtcblxuICAgICAgICB2YXIgdGh1bWJQcm9wcyA9IHtcbiAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuc2V0VGh1bWJzUmVmKGUsIGluZGV4KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsYXNzTmFtZTogaXRlbUNsYXNzLFxuICAgICAgICAgIG9uQ2xpY2s6IF90aGlzMi5oYW5kbGVDbGlja0l0ZW0uYmluZChfdGhpczIsIGluZGV4LCBfdGhpczIucHJvcHMuY2hpbGRyZW5baW5kZXhdKSxcbiAgICAgICAgICBvbktleURvd246IF90aGlzMi5oYW5kbGVDbGlja0l0ZW0uYmluZChfdGhpczIsIGluZGV4LCBfdGhpczIucHJvcHMuY2hpbGRyZW5baW5kZXhdKSxcbiAgICAgICAgICAnYXJpYS1sYWJlbCc6IFwiXCIuY29uY2F0KF90aGlzMi5wcm9wcy5sYWJlbHMuaXRlbSwgXCIgXCIpLmNvbmNhdChpbmRleCArIDEpLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogX3RoaXMyLnByb3BzLnRodW1iV2lkdGhcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImxpXCIsIF9leHRlbmRzKHt9LCB0aHVtYlByb3BzLCB7XG4gICAgICAgICAgcm9sZTogXCJidXR0b25cIixcbiAgICAgICAgICB0YWJJbmRleDogMFxuICAgICAgICB9KSwgaW1nKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzU3dpcGVhYmxlID0gX3JlYWN0LkNoaWxkcmVuLmNvdW50KHRoaXMucHJvcHMuY2hpbGRyZW4pID4gMTsgLy8gc2hvdyBsZWZ0IGFycm93P1xuXG4gICAgICB2YXIgaGFzUHJldiA9IHRoaXMuc3RhdGUuc2hvd0Fycm93cyAmJiB0aGlzLnN0YXRlLmZpcnN0SXRlbSA+IDA7IC8vIHNob3cgcmlnaHQgYXJyb3dcblxuICAgICAgdmFyIGhhc05leHQgPSB0aGlzLnN0YXRlLnNob3dBcnJvd3MgJiYgdGhpcy5zdGF0ZS5maXJzdEl0ZW0gPCB0aGlzLnN0YXRlLmxhc3RQb3NpdGlvbjsgLy8gb2JqIHRvIGhvbGQgdGhlIHRyYW5zZm9ybWF0aW9ucyBhbmQgc3R5bGVzXG5cbiAgICAgIHZhciBpdGVtTGlzdFN0eWxlcyA9IHt9O1xuICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IC10aGlzLnN0YXRlLmZpcnN0SXRlbSAqICh0aGlzLnN0YXRlLml0ZW1TaXplIHx8IDApO1xuICAgICAgdmFyIHRyYW5zZm9ybVByb3AgPSAoMCwgX0NTU1RyYW5zbGF0ZS5kZWZhdWx0KShjdXJyZW50UG9zaXRpb24sICdweCcsIHRoaXMucHJvcHMuYXhpcyk7XG4gICAgICB2YXIgdHJhbnNpdGlvblRpbWUgPSB0aGlzLnByb3BzLnRyYW5zaXRpb25UaW1lICsgJ21zJztcbiAgICAgIGl0ZW1MaXN0U3R5bGVzID0ge1xuICAgICAgICBXZWJraXRUcmFuc2Zvcm06IHRyYW5zZm9ybVByb3AsXG4gICAgICAgIE1velRyYW5zZm9ybTogdHJhbnNmb3JtUHJvcCxcbiAgICAgICAgTXNUcmFuc2Zvcm06IHRyYW5zZm9ybVByb3AsXG4gICAgICAgIE9UcmFuc2Zvcm06IHRyYW5zZm9ybVByb3AsXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtUHJvcCxcbiAgICAgICAgbXNUcmFuc2Zvcm06IHRyYW5zZm9ybVByb3AsXG4gICAgICAgIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvblRpbWUsXG4gICAgICAgIE1velRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvblRpbWUsXG4gICAgICAgIE1zVHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uVGltZSxcbiAgICAgICAgT1RyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvblRpbWUsXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvblRpbWUsXG4gICAgICAgIG1zVHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uVGltZVxuICAgICAgfTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogX2Nzc0NsYXNzZXMuZGVmYXVsdC5DQVJPVVNFTChmYWxzZSlcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBfY3NzQ2xhc3Nlcy5kZWZhdWx0LldSQVBQRVIoZmFsc2UpLFxuICAgICAgICByZWY6IHRoaXMuc2V0SXRlbXNXcmFwcGVyUmVmXG4gICAgICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgIGNsYXNzTmFtZTogX2Nzc0NsYXNzZXMuZGVmYXVsdC5BUlJPV19QUkVWKCFoYXNQcmV2KSxcbiAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLnNsaWRlUmlnaHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMucHJvcHMubGFiZWxzLmxlZnRBcnJvd1xuICAgICAgfSksIGlzU3dpcGVhYmxlID8gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0RWFzeVN3aXBlLmRlZmF1bHQsIHtcbiAgICAgICAgdGFnTmFtZTogXCJ1bFwiLFxuICAgICAgICBjbGFzc05hbWU6IF9jc3NDbGFzc2VzLmRlZmF1bHQuU0xJREVSKGZhbHNlLCB0aGlzLnN0YXRlLnN3aXBpbmcpLFxuICAgICAgICBvblN3aXBlTGVmdDogdGhpcy5zbGlkZUxlZnQsXG4gICAgICAgIG9uU3dpcGVSaWdodDogdGhpcy5zbGlkZVJpZ2h0LFxuICAgICAgICBvblN3aXBlTW92ZTogdGhpcy5vblN3aXBlTW92ZSxcbiAgICAgICAgb25Td2lwZVN0YXJ0OiB0aGlzLm9uU3dpcGVTdGFydCxcbiAgICAgICAgb25Td2lwZUVuZDogdGhpcy5vblN3aXBlRW5kLFxuICAgICAgICBzdHlsZTogaXRlbUxpc3RTdHlsZXMsXG4gICAgICAgIGlubmVyUmVmOiB0aGlzLnNldEl0ZW1zTGlzdFJlZixcbiAgICAgICAgYWxsb3dNb3VzZUV2ZW50czogdGhpcy5wcm9wcy5lbXVsYXRlVG91Y2hcbiAgICAgIH0sIHRoaXMucmVuZGVySXRlbXMoKSkgOiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInVsXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBfY3NzQ2xhc3Nlcy5kZWZhdWx0LlNMSURFUihmYWxzZSwgdGhpcy5zdGF0ZS5zd2lwaW5nKSxcbiAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuc2V0SXRlbXNMaXN0UmVmKG5vZGUpO1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogaXRlbUxpc3RTdHlsZXNcbiAgICAgIH0sIHRoaXMucmVuZGVySXRlbXMoKSksIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgY2xhc3NOYW1lOiBfY3NzQ2xhc3Nlcy5kZWZhdWx0LkFSUk9XX05FWFQoIWhhc05leHQpLFxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuc2xpZGVMZWZ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnByb3BzLmxhYmVscy5yaWdodEFycm93XG4gICAgICB9KSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUaHVtYnM7XG59KF9yZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUaHVtYnM7XG5cbl9kZWZpbmVQcm9wZXJ0eShUaHVtYnMsIFwiZGlzcGxheU5hbWVcIiwgJ1RodW1icycpO1xuXG5fZGVmaW5lUHJvcGVydHkoVGh1bWJzLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIGF4aXM6ICdob3Jpem9udGFsJyxcbiAgbGFiZWxzOiB7XG4gICAgbGVmdEFycm93OiAncHJldmlvdXMgc2xpZGUgLyBpdGVtJyxcbiAgICByaWdodEFycm93OiAnbmV4dCBzbGlkZSAvIGl0ZW0nLFxuICAgIGl0ZW06ICdzbGlkZSBpdGVtJ1xuICB9LFxuICBzZWxlY3RlZEl0ZW06IDAsXG4gIHRodW1iV2lkdGg6IDgwLFxuICB0cmFuc2l0aW9uVGltZTogMzUwXG59KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-responsive-carousel/lib/js/components/Thumbs.js\n");

/***/ }),

/***/ "./node_modules/react-responsive-carousel/lib/js/cssClasses.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-responsive-carousel/lib/js/cssClasses.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"./node_modules/classnames/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar _default = {\n  ROOT: function ROOT(customClassName) {\n    return (0, _classnames.default)(_defineProperty({\n      'carousel-root': true\n    }, customClassName || '', !!customClassName));\n  },\n  CAROUSEL: function CAROUSEL(isSlider) {\n    return (0, _classnames.default)({\n      carousel: true,\n      'carousel-slider': isSlider\n    });\n  },\n  WRAPPER: function WRAPPER(isSlider, axis) {\n    return (0, _classnames.default)({\n      'thumbs-wrapper': !isSlider,\n      'slider-wrapper': isSlider,\n      'axis-horizontal': axis === 'horizontal',\n      'axis-vertical': axis !== 'horizontal'\n    });\n  },\n  SLIDER: function SLIDER(isSlider, isSwiping) {\n    return (0, _classnames.default)({\n      thumbs: !isSlider,\n      slider: isSlider,\n      animated: !isSwiping\n    });\n  },\n  ITEM: function ITEM(isSlider, selected, previous) {\n    return (0, _classnames.default)({\n      thumb: !isSlider,\n      slide: isSlider,\n      selected: selected,\n      previous: previous\n    });\n  },\n  ARROW_PREV: function ARROW_PREV(disabled) {\n    return (0, _classnames.default)({\n      'control-arrow control-prev': true,\n      'control-disabled': disabled\n    });\n  },\n  ARROW_NEXT: function ARROW_NEXT(disabled) {\n    return (0, _classnames.default)({\n      'control-arrow control-next': true,\n      'control-disabled': disabled\n    });\n  },\n  DOT: function DOT(selected) {\n    return (0, _classnames.default)({\n      dot: true,\n      selected: selected\n    });\n  }\n};\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2pzL2Nzc0NsYXNzZXMuanM/NWRiOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixlQUFlOztBQUVmLHlDQUF5QyxtQkFBTyxDQUFDLHNEQUFZOztBQUU3RCxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0YsMkNBQTJDLGtCQUFrQixrQ0FBa0MscUVBQXFFLEVBQUUsRUFBRSxPQUFPLGtCQUFrQixFQUFFLFlBQVk7O0FBRS9NO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS1jYXJvdXNlbC9saWIvanMvY3NzQ2xhc3Nlcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzbmFtZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIF9kZWZhdWx0ID0ge1xuICBST09UOiBmdW5jdGlvbiBST09UKGN1c3RvbUNsYXNzTmFtZSkge1xuICAgIHJldHVybiAoMCwgX2NsYXNzbmFtZXMuZGVmYXVsdCkoX2RlZmluZVByb3BlcnR5KHtcbiAgICAgICdjYXJvdXNlbC1yb290JzogdHJ1ZVxuICAgIH0sIGN1c3RvbUNsYXNzTmFtZSB8fCAnJywgISFjdXN0b21DbGFzc05hbWUpKTtcbiAgfSxcbiAgQ0FST1VTRUw6IGZ1bmN0aW9uIENBUk9VU0VMKGlzU2xpZGVyKSB7XG4gICAgcmV0dXJuICgwLCBfY2xhc3NuYW1lcy5kZWZhdWx0KSh7XG4gICAgICBjYXJvdXNlbDogdHJ1ZSxcbiAgICAgICdjYXJvdXNlbC1zbGlkZXInOiBpc1NsaWRlclxuICAgIH0pO1xuICB9LFxuICBXUkFQUEVSOiBmdW5jdGlvbiBXUkFQUEVSKGlzU2xpZGVyLCBheGlzKSB7XG4gICAgcmV0dXJuICgwLCBfY2xhc3NuYW1lcy5kZWZhdWx0KSh7XG4gICAgICAndGh1bWJzLXdyYXBwZXInOiAhaXNTbGlkZXIsXG4gICAgICAnc2xpZGVyLXdyYXBwZXInOiBpc1NsaWRlcixcbiAgICAgICdheGlzLWhvcml6b250YWwnOiBheGlzID09PSAnaG9yaXpvbnRhbCcsXG4gICAgICAnYXhpcy12ZXJ0aWNhbCc6IGF4aXMgIT09ICdob3Jpem9udGFsJ1xuICAgIH0pO1xuICB9LFxuICBTTElERVI6IGZ1bmN0aW9uIFNMSURFUihpc1NsaWRlciwgaXNTd2lwaW5nKSB7XG4gICAgcmV0dXJuICgwLCBfY2xhc3NuYW1lcy5kZWZhdWx0KSh7XG4gICAgICB0aHVtYnM6ICFpc1NsaWRlcixcbiAgICAgIHNsaWRlcjogaXNTbGlkZXIsXG4gICAgICBhbmltYXRlZDogIWlzU3dpcGluZ1xuICAgIH0pO1xuICB9LFxuICBJVEVNOiBmdW5jdGlvbiBJVEVNKGlzU2xpZGVyLCBzZWxlY3RlZCwgcHJldmlvdXMpIHtcbiAgICByZXR1cm4gKDAsIF9jbGFzc25hbWVzLmRlZmF1bHQpKHtcbiAgICAgIHRodW1iOiAhaXNTbGlkZXIsXG4gICAgICBzbGlkZTogaXNTbGlkZXIsXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBwcmV2aW91czogcHJldmlvdXNcbiAgICB9KTtcbiAgfSxcbiAgQVJST1dfUFJFVjogZnVuY3Rpb24gQVJST1dfUFJFVihkaXNhYmxlZCkge1xuICAgIHJldHVybiAoMCwgX2NsYXNzbmFtZXMuZGVmYXVsdCkoe1xuICAgICAgJ2NvbnRyb2wtYXJyb3cgY29udHJvbC1wcmV2JzogdHJ1ZSxcbiAgICAgICdjb250cm9sLWRpc2FibGVkJzogZGlzYWJsZWRcbiAgICB9KTtcbiAgfSxcbiAgQVJST1dfTkVYVDogZnVuY3Rpb24gQVJST1dfTkVYVChkaXNhYmxlZCkge1xuICAgIHJldHVybiAoMCwgX2NsYXNzbmFtZXMuZGVmYXVsdCkoe1xuICAgICAgJ2NvbnRyb2wtYXJyb3cgY29udHJvbC1uZXh0JzogdHJ1ZSxcbiAgICAgICdjb250cm9sLWRpc2FibGVkJzogZGlzYWJsZWRcbiAgICB9KTtcbiAgfSxcbiAgRE9UOiBmdW5jdGlvbiBET1Qoc2VsZWN0ZWQpIHtcbiAgICByZXR1cm4gKDAsIF9jbGFzc25hbWVzLmRlZmF1bHQpKHtcbiAgICAgIGRvdDogdHJ1ZSxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZFxuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-responsive-carousel/lib/js/cssClasses.js\n");

/***/ }),

/***/ "./node_modules/react-responsive-carousel/lib/js/dimensions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-responsive-carousel/lib/js/dimensions.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.outerWidth = void 0;\n\nvar outerWidth = function outerWidth(el) {\n  var width = el.offsetWidth;\n  var style = getComputedStyle(el);\n  width += parseInt(style.marginLeft) + parseInt(style.marginRight);\n  return width;\n};\n\nexports.outerWidth = outerWidth;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2pzL2RpbWVuc2lvbnMuanM/ZDRhNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS1jYXJvdXNlbC9saWIvanMvZGltZW5zaW9ucy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5vdXRlcldpZHRoID0gdm9pZCAwO1xuXG52YXIgb3V0ZXJXaWR0aCA9IGZ1bmN0aW9uIG91dGVyV2lkdGgoZWwpIHtcbiAgdmFyIHdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG4gIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB3aWR0aCArPSBwYXJzZUludChzdHlsZS5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KHN0eWxlLm1hcmdpblJpZ2h0KTtcbiAgcmV0dXJuIHdpZHRoO1xufTtcblxuZXhwb3J0cy5vdXRlcldpZHRoID0gb3V0ZXJXaWR0aDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-responsive-carousel/lib/js/dimensions.js\n");

/***/ }),

/***/ "./node_modules/react-responsive-carousel/lib/js/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-responsive-carousel/lib/js/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"Carousel\", ({\n  enumerable: true,\n  get: function get() {\n    return _Carousel.default;\n  }\n}));\nObject.defineProperty(exports, \"CarouselProps\", ({\n  enumerable: true,\n  get: function get() {\n    return _types.CarouselProps;\n  }\n}));\nObject.defineProperty(exports, \"Thumbs\", ({\n  enumerable: true,\n  get: function get() {\n    return _Thumbs.default;\n  }\n}));\n\nvar _Carousel = _interopRequireDefault(__webpack_require__(/*! ./components/Carousel */ \"./node_modules/react-responsive-carousel/lib/js/components/Carousel/index.js\"));\n\nvar _types = __webpack_require__(/*! ./components/Carousel/types */ \"./node_modules/react-responsive-carousel/lib/js/components/Carousel/types.js\");\n\nvar _Thumbs = _interopRequireDefault(__webpack_require__(/*! ./components/Thumbs */ \"./node_modules/react-responsive-carousel/lib/js/components/Thumbs.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2pzL2luZGV4LmpzP2ExMzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLHVDQUF1QyxtQkFBTyxDQUFDLDJHQUF1Qjs7QUFFdEUsYUFBYSxtQkFBTyxDQUFDLGlIQUE2Qjs7QUFFbEQscUNBQXFDLG1CQUFPLENBQUMsaUdBQXFCOztBQUVsRSxzQ0FBc0MsdUNBQXVDLGdCQUFnQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsL2xpYi9qcy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2Fyb3VzZWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Nhcm91c2VsLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2Fyb3VzZWxQcm9wc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZXMuQ2Fyb3VzZWxQcm9wcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaHVtYnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1RodW1icy5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9DYXJvdXNlbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50cy9DYXJvdXNlbFwiKSk7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL0Nhcm91c2VsL3R5cGVzXCIpO1xuXG52YXIgX1RodW1icyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50cy9UaHVtYnNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-responsive-carousel/lib/js/index.js\n");

/***/ }),

/***/ "./node_modules/react-responsive-carousel/lib/js/shims/document.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-responsive-carousel/lib/js/shims/document.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _default = function _default() {\n  return document;\n};\n\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2pzL3NoaW1zL2RvY3VtZW50LmpzPzY3ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7O0FBRUEsZUFBZSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsL2xpYi9qcy9zaGltcy9kb2N1bWVudC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIGRvY3VtZW50O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-responsive-carousel/lib/js/shims/document.js\n");

/***/ }),

/***/ "./node_modules/react-responsive-carousel/lib/js/shims/window.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-responsive-carousel/lib/js/shims/window.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _default = function _default() {\n  return window;\n};\n\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2pzL3NoaW1zL3dpbmRvdy5qcz9lMTUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGVBQWU7O0FBRWY7QUFDQTtBQUNBOztBQUVBLGVBQWUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS1jYXJvdXNlbC9saWIvanMvc2hpbXMvd2luZG93LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICByZXR1cm4gd2luZG93O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-responsive-carousel/lib/js/shims/window.js\n");

/***/ })

});